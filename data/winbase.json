{
    "functions": [
        {
            "name": "_lclose",
            "return_type": "HFILE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_lclose",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HFILE",
                    "description": " Identifies the file to be closed. This handle is returned by the function that created or last opened the file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "_lcreat",
            "return_type": "HFILE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_lcreat",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCSTR",
                    "description": " The name of the file. The string must consist of characters from the Windows ANSI character set.",
                    "possible_constants": []
                },
                {
                    "name": "iAttribute",
                    "type": "int",
                    "description": " The attributes of the file. This parameter must be set to one of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "_llseek",
            "return_type": "LONG",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_llseek",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HFILE",
                    "description": " A handle to an open file. This handle is created by _lcreat.",
                    "possible_constants": []
                },
                {
                    "name": "lOffset",
                    "type": "LONG",
                    "description": " The number of bytes that the file pointer is to be moved.",
                    "possible_constants": []
                },
                {
                    "name": "iOrigin",
                    "type": "int",
                    "description": " The starting point and the direction that the pointer will be moved. This parameter must be set to one of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "_lopen",
            "return_type": "HFILE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_lopen",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCSTR",
                    "description": " Pointer to a null-terminated string that names the file to open. The string must consist of characters from the Windows ANSI character set.",
                    "possible_constants": []
                },
                {
                    "name": "iReadWrite",
                    "type": "int",
                    "description": " Specifies the modes in which to open the file. This parameter consists of one access mode and an optional share mode. The access mode must be one of the following values: OF_READ,  OF_READWRITE, OF_WRITE The share mode can be one of the following values: OF_SHARE_COMPAT,  OF_SHARE_DENY_NONE, OF_SHARE_DENY_READ, OF_SHARE_DENY_WRITE, OF_SHARE_EXCLUSIVE",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "_lread",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_lread",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HFILE",
                    "description": " Identifies the specified file.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": " Pointer to a buffer that contains the data read from the file.",
                    "possible_constants": []
                },
                {
                    "name": "uBytes",
                    "type": "UINT",
                    "description": " Specifies the number of bytes to be read from the file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "_lwrite",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-_lwrite",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HFILE",
                    "description": " A handle to the file that receives the data. This handle is created by _lcreat.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPCCH",
                    "description": " The buffer that contains the data to be added.",
                    "possible_constants": []
                },
                {
                    "name": "uBytes",
                    "type": "UINT",
                    "description": " The number of bytes to write to the file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AccessCheckAndAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-accesscheckandauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeName",
                    "type": "LPSTR",
                    "description": "A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectName",
                    "type": "LPSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "SecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to the\nSECURITY_DESCRIPTOR structure against which access is checked.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "Access mask that specifies the access rights to check. This mask must have been mapped by the\nMapGenericMask function to contain no generic access rights. If this parameter is MAXIMUM_ALLOWED, the function sets the GrantedAccess access mask to indicate the maximum access rights the security descriptor allows the client.",
                    "possible_constants": []
                },
                {
                    "name": "GenericMapping",
                    "type": "PGENERIC_MAPPING",
                    "description": "A pointer to the\nGENERIC_MAPPING structure associated with the object for which access is being checked.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectCreation",
                    "type": "BOOL",
                    "description": "Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of TRUE indicates the application will create a new object. A value of FALSE indicates the application will open an existing object. [out] GrantedAccess A pointer to an access mask that receives the granted access rights. If AccessStatus is set to FALSE, the function sets the access mask to zero. If the function fails, it does not set the access mask. [out] AccessStatus A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, AccessStatus is set to TRUE. Otherwise, AccessStatus is set to FALSE. [out] pfGenerateOnClose A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the\nObjectCloseAuditAlarm function when the object handle is closed.",
                    "possible_constants": []
                },
                {
                    "name": "GrantedAccess",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "AccessStatus",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pfGenerateOnClose",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AccessCheckByTypeAndAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-accesscheckbytypeandauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "SecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to a\nSECURITY_DESCRIPTOR structure against which access is checked.",
                    "possible_constants": []
                },
                {
                    "name": "PrincipalSelfSid",
                    "type": "PSID",
                    "description": "A pointer to a security identifier (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the PrincipalSelfSid parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see Well-known SIDs. If the protected object does not represent a principal, set this parameter to NULL.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "An access mask that specifies the access rights to check. This mask must have been mapped by the\nMapGenericMask function to contain no generic access rights. If this parameter is MAXIMUM_ALLOWED, the function sets the GrantedAccess access mask to indicate the maximum access rights the security descriptor allows the client.",
                    "possible_constants": []
                },
                {
                    "name": "AuditType",
                    "type": "AUDIT_EVENT_TYPE",
                    "description": "The type of audit to be generated. This can be one of the values from the\nAUDIT_EVENT_TYPE enumeration type.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "A flag that controls the function's behavior if the calling process does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeList",
                    "type": "POBJECT_TYPE_LIST",
                    "description": "The number of elements in the ObjectTypeList array.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeListLength",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "GenericMapping",
                    "type": "PGENERIC_MAPPING",
                    "description": "A pointer to the\nGENERIC_MAPPING structure associated with the object for which access is being checked.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectCreation",
                    "type": "BOOL",
                    "description": "A flag that determines whether the calling application will create a new object when access is granted. A value of TRUE indicates the application will create a new object. A value of FALSE indicates the application will open an existing object. [out] GrantedAccess A pointer to an access mask that receives the granted access rights. If AccessStatus is set to FALSE, the function sets the access mask to zero. If the function fails, it does not set the access mask. [out] AccessStatus A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, AccessStatus is set to TRUE. Otherwise, AccessStatus is set to FALSE and you can call\nGetLastError to get extended error information. [out] pfGenerateOnClose A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the\nObjectCloseAuditAlarm function when the object handle is closed.",
                    "possible_constants": []
                },
                {
                    "name": "GrantedAccess",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "AccessStatus",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pfGenerateOnClose",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AccessCheckByTypeResultListAndAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-accesscheckbytyperesultlistandauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "SecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to a\nSECURITY_DESCRIPTOR structure against which access is checked.",
                    "possible_constants": []
                },
                {
                    "name": "PrincipalSelfSid",
                    "type": "PSID",
                    "description": "A pointer to a security identifier (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the PrincipalSelfSid parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see Well-known SIDs. Set this parameter to NULL if the protected object does not represent a principal.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "An access mask that specifies the access rights to check. This mask must have been mapped by the\nMapGenericMask function so that it contains no generic access rights. If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in GrantedAccess to indicate the maximum access rights the security descriptor allows the client.",
                    "possible_constants": []
                },
                {
                    "name": "AuditType",
                    "type": "AUDIT_EVENT_TYPE",
                    "description": "The type of audit to be generated. This can be one of the values from the\nAUDIT_EVENT_TYPE enumeration type.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "A flag that controls the function's behavior if the calling process does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeList",
                    "type": "POBJECT_TYPE_LIST",
                    "description": "The number of elements in the ObjectTypeList array.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeListLength",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "GenericMapping",
                    "type": "PGENERIC_MAPPING",
                    "description": "A pointer to the\nGENERIC_MAPPING structure associated with the object for which access is being checked.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectCreation",
                    "type": "BOOL",
                    "description": "A flag that determines whether the calling application will create a new object when access is granted. A value of TRUE indicates the application will create a new object. A value of FALSE indicates the application will open an existing object. [out] GrantedAccess A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks. [out] AccessStatusList A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array. [out] pfGenerateOnClose A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the\nObjectCloseAuditAlarm function when the object handle is closed.",
                    "possible_constants": []
                },
                {
                    "name": "GrantedAccess",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "AccessStatusList",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pfGenerateOnClose",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AccessCheckByTypeResultListAndAuditAlarmByHandleA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-accesscheckbytyperesultlistandauditalarmbyhandlea",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.",
                    "possible_constants": []
                },
                {
                    "name": "ClientToken",
                    "type": "HANDLE",
                    "description": "A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "SecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to a\nSECURITY_DESCRIPTOR structure against which access is checked.",
                    "possible_constants": []
                },
                {
                    "name": "PrincipalSelfSid",
                    "type": "PSID",
                    "description": "A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the PrincipalSelfSid parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see Well-known SIDs. Set this parameter to NULL if the protected object does not represent a principal.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "An access mask that specifies the access rights to check. This mask must have been mapped by the\nMapGenericMask function so that it contains no generic access rights. If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in GrantedAccess to indicate the maximum access rights the security descriptor allows the client.",
                    "possible_constants": []
                },
                {
                    "name": "AuditType",
                    "type": "AUDIT_EVENT_TYPE",
                    "description": "The type of audit to be generated. This can be one of the values from the\nAUDIT_EVENT_TYPE enumeration type.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "A flag that controls the function's behavior if the calling process does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeList",
                    "type": "POBJECT_TYPE_LIST",
                    "description": "The number of elements in the ObjectTypeList array.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeListLength",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "GenericMapping",
                    "type": "PGENERIC_MAPPING",
                    "description": "A pointer to the\nGENERIC_MAPPING structure associated with the object for which access is being checked.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectCreation",
                    "type": "BOOL",
                    "description": "A flag that determines whether the calling application will create a new object when access is granted. A value of TRUE indicates the application will create a new object. A value of FALSE indicates the application will open an existing object. [out] GrantedAccess A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks. [out] AccessStatusList A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array. [out] pfGenerateOnClose A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the\nObjectCloseAuditAlarm function when the object handle is closed.",
                    "possible_constants": []
                },
                {
                    "name": "GrantedAccess",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "AccessStatusList",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pfGenerateOnClose",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ActivateActCtx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-activateactctx",
            "description": "",
            "parameters": [
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "Handle to an\nACTCTX structure that contains information on the activation context that is to be made active. [out] lpCookie Pointer to a ULONG_PTR that functions as a cookie, uniquely identifying a specific, activated activation context.",
                    "possible_constants": []
                },
                {
                    "name": "*lpCookie",
                    "type": "ULONG_PTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddAtomA",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addatoma",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the GetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddAtomW",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addatomw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the GetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddConditionalAce",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addconditionalace",
            "description": "",
            "parameters": [
                {
                    "name": "pAcl",
                    "type": "PACL",
                    "description": "A pointer to an\nACL. This function adds an ACE to this ACL. The value of this parameter cannot be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwAceRevision",
                    "type": "DWORD",
                    "description": "Specifies the revision level of the ACL being modified. This value can be ACL_REVISION or ACL_REVISION_DS.\nUse ACL_REVISION_DS if the ACL contains object-specific ACEs.",
                    "possible_constants": []
                },
                {
                    "name": "AceFlags",
                    "type": "DWORD",
                    "description": "A set of bit flags that control ACE inheritance. The function sets these flags in the AceFlags member of the\nACE_HEADER structure of the new ACE. This parameter can be a combination of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "AceType",
                    "type": "UCHAR",
                    "description": "The type of the ACE. This can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "AccessMask",
                    "type": "DWORD",
                    "description": "Specifies the mask of access rights to be granted to the specified SID.",
                    "possible_constants": []
                },
                {
                    "name": "pSid",
                    "type": "PSID",
                    "description": "A pointer to the\nSID  that represents a user, group, or logon account being granted access.",
                    "possible_constants": []
                },
                {
                    "name": "ConditionStr",
                    "type": "PWCHAR",
                    "description": "A string that specifies the conditional statement to be evaluated for the ACE. [out] ReturnLength The size, in bytes, of the ACL. If the buffer specified by the pACL parameter is not of sufficient size, the value of this parameter is the required size.",
                    "possible_constants": []
                },
                {
                    "name": "*ReturnLength",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddIntegrityLabelToBoundaryDescriptor",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addintegritylabeltoboundarydescriptor",
            "description": "",
            "parameters": [
                {
                    "name": "*BoundaryDescriptor",
                    "type": "HANDLE",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "IntegrityLabel",
                    "type": "PSID",
                    "description": "A pointer to a SID structure that represents the mandatory integrity level for the namespace. Use one of the following RID values to create the SID: SECURITY_MANDATORY_UNTRUSTED_RID\nSECURITY_MANDATORY_LOW_RID\nSECURITY_MANDATORY_MEDIUM_RID\nSECURITY_MANDATORY_SYSTEM_RID\nSECURITY_MANDATORY_PROTECTED_PROCESS_RID\nFor more information, see Well-Known SIDs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddRefActCtx",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addrefactctx",
            "description": "",
            "parameters": [
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "Handle to an\nACTCTX structure that contains information on the activation context for which the reference count is to be incremented.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "AddSecureMemoryCacheCallback",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-addsecurememorycachecallback",
            "description": "",
            "parameters": [
                {
                    "name": "pfnCallBack",
                    "type": "PSECURE_MEMORY_CACHE_CALLBACK",
                    "description": "A pointer to the application-defined\nSecureMemoryCacheCallback function to\nregister.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ApplicationRecoveryFinished",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-applicationrecoveryfinished",
            "description": "",
            "parameters": [
                {
                    "name": "bSuccess",
                    "type": "BOOL",
                    "description": "Specify TRUE to indicate that the data was successfully recovered; otherwise, FALSE.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ApplicationRecoveryInProgress",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-applicationrecoveryinprogress",
            "description": "",
            "parameters": [
                {
                    "name": "pbCancelled",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BackupEventLogA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-backupeventloga",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the open event log. The OpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCSTR",
                    "description": "The absolute or relative path of the backup file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BackupEventLogW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-backupeventlogw",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the open event log. The OpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCWSTR",
                    "description": "The absolute or relative path of the backup file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BackupRead",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-backupread",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "Handle to the file or directory to be backed up. To obtain the handle, call the CreateFile function. The SACLs are not read unless the file handle was created with the ACCESS_SYSTEM_SECURITY access right. For more information, see File security and access rights. The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when CreateFile is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug. The BackupRead function may fail if\nCreateFile was called with the flag\nFILE_FLAG_NO_BUFFERING. In this case, the\nGetLastError function returns the value\nERROR_INVALID_PARAMETER. [out] lpBuffer Pointer to a buffer that receives the data.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPBYTE",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nNumberOfBytesToRead",
                    "type": "DWORD",
                    "description": "Length of the buffer, in bytes. The buffer size must be greater than the size of a\nWIN32_STREAM_ID structure. [out] lpNumberOfBytesRead Pointer to a variable that receives the number of bytes read. If the function returns a nonzero value, and the variable pointed to by\nlpNumberOfBytesRead is zero, then all the data associated with the file handle has\nbeen read.",
                    "possible_constants": []
                },
                {
                    "name": "lpNumberOfBytesRead",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "bAbort",
                    "type": "BOOL",
                    "description": "Indicates whether you have finished using BackupRead\non the handle. While you are backing up the file, specify this parameter as FALSE.\nOnce you are done using BackupRead, you must call\nBackupRead one more time specifying\nTRUE for this parameter and passing the appropriate\nlpContext. lpContext must be passed when\nbAbort is TRUE; all other parameters are ignored.",
                    "possible_constants": []
                },
                {
                    "name": "bProcessSecurity",
                    "type": "BOOL",
                    "description": "Indicates whether the function will restore the access-control list (ACL) data for the file or directory. If bProcessSecurity is TRUE, the ACL data will be backed\nup. [out] lpContext Pointer to a variable that receives a pointer to an internal data structure used by\nBackupRead to maintain context information during a\nbackup operation. You must set the variable pointed to by lpContext to NULL\nbefore the first call to BackupRead for the specified\nfile or directory. The function allocates memory for the data structure, and then sets the variable to point to\nthat structure. You must not change lpContext or the variable that it points to\nbetween calls to BackupRead. To release the memory used by the data structure, call\nBackupRead with the\nbAbort parameter set to TRUE when the backup operation is complete.",
                    "possible_constants": []
                },
                {
                    "name": "*lpContext",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BackupSeek",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-backupseek",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "Handle to the file or directory. This handle is created by using the\nCreateFile function. The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when CreateFile is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.",
                    "possible_constants": []
                },
                {
                    "name": "dwLowBytesToSeek",
                    "type": "DWORD",
                    "description": "Low-order part of the number of bytes to seek.",
                    "possible_constants": []
                },
                {
                    "name": "dwHighBytesToSeek",
                    "type": "DWORD",
                    "description": "High-order part of the number of bytes to seek. [out] lpdwLowByteSeeked Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks. [out] lpdwHighByteSeeked Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks. [in] lpContext Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the\nBackupRead or BackupWrite function. An application must not touch the contents of this structure.",
                    "possible_constants": []
                },
                {
                    "name": "lpdwLowByteSeeked",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwHighByteSeeked",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*lpContext",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BackupWrite",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-backupwrite",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "Handle to the file or directory to be restored. To obtain the handle, call the CreateFile function. The SACLs are not restored unless the file handle was created with the ACCESS_SYSTEM_SECURITY access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the WRITE_OWNER access right. For more information, see File security and access rights. The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when CreateFile is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug. The BackupWrite function may fail if\nCreateFile was called with the flag\nFILE_FLAG_NO_BUFFERING. In this case, the\nGetLastError function returns the value\nERROR_INVALID_PARAMETER.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPBYTE",
                    "description": "Pointer to a buffer that the function writes data from.",
                    "possible_constants": []
                },
                {
                    "name": "nNumberOfBytesToWrite",
                    "type": "DWORD",
                    "description": "Size of the buffer, in bytes. The buffer size must be greater than the size of a\nWIN32_STREAM_ID structure. [out] lpNumberOfBytesWritten Pointer to a variable that receives the number of bytes written.",
                    "possible_constants": []
                },
                {
                    "name": "lpNumberOfBytesWritten",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "bAbort",
                    "type": "BOOL",
                    "description": "Indicates whether you have finished using BackupWrite on the handle.\nWhile you are restoring the file, specify this parameter as FALSE. After you are done\nusing BackupWrite, you must call BackupWrite\none more time specifying TRUE for this parameter and passing the appropriate\nlpContext. lpContext must be passed when\nbAbort is TRUE; all other parameters are ignored.",
                    "possible_constants": []
                },
                {
                    "name": "bProcessSecurity",
                    "type": "BOOL",
                    "description": "Specifies whether the function will restore the access-control list (ACL) data for the file or directory. If bProcessSecurity is TRUE, you need to specify\nWRITE_OWNER and WRITE_DAC access when opening the file or\ndirectory handle. If the handle does not have those access rights, the operating system denies access to the\nACL data, and ACL data restoration will not occur. [out] lpContext Pointer to a variable that receives a pointer to an internal data structure used by\nBackupWrite to maintain context information during a restore operation. You must set the variable pointed to by lpContext to NULL\nbefore the first call to BackupWrite for the specified file or directory. The\nfunction allocates memory for the data structure, and then sets the variable to point to that structure. You\nmust not change lpContext or the variable that it points to between calls to\nBackupWrite. To release the memory used by the data structure, call BackupWrite with the\nbAbort parameter set to TRUE when the restore operation is\ncomplete.",
                    "possible_constants": []
                },
                {
                    "name": "*lpContext",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BeginUpdateResourceA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-beginupdateresourcea",
            "description": "",
            "parameters": [
                {
                    "name": "pFileName",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by pFileName cannot be currently executing. If pFileName does not specify a full path, the system searches for the file in the current directory.",
                    "possible_constants": []
                },
                {
                    "name": "bDeleteExistingResources",
                    "type": "BOOL",
                    "description": "Type: BOOL Indicates whether to delete the pFileName parameter's existing resources. If this parameter is TRUE, existing resources are deleted and the updated file includes only resources added with the UpdateResource function. If this parameter is FALSE, the updated file includes existing resources unless they are explicitly deleted or replaced by using UpdateResource.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BeginUpdateResourceW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-beginupdateresourcew",
            "description": "",
            "parameters": [
                {
                    "name": "pFileName",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by pFileName cannot be currently executing. If pFileName does not specify a full path, the system searches for the file in the current directory.",
                    "possible_constants": []
                },
                {
                    "name": "bDeleteExistingResources",
                    "type": "BOOL",
                    "description": "Type: BOOL Indicates whether to delete the pFileName parameter's existing resources. If this parameter is TRUE, existing resources are deleted and the updated file includes only resources added with the UpdateResource function. If this parameter is FALSE, the updated file includes existing resources unless they are explicitly deleted or replaced by using UpdateResource.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BindIoCompletionCallback",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-bindiocompletioncallback",
            "description": "",
            "parameters": [
                {
                    "name": "FileHandle",
                    "type": "HANDLE",
                    "description": "A handle to the file opened for overlapped I/O completion. This handle is returned by the\nCreateFile function, with the FILE_FLAG_OVERLAPPED flag.",
                    "possible_constants": []
                },
                {
                    "name": "Function",
                    "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
                    "description": "A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete. This callback function must not call the\nTerminateThread function. For more information about the completion routine, see\nFileIOCompletionRoutine.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "ULONG",
                    "description": "This parameter must be zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BuildCommDCBA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-buildcommdcba",
            "description": "",
            "parameters": [
                {
                    "name": "lpDef",
                    "type": "LPCSTR",
                    "description": "The device-control information. The function takes this string, parses it, and then sets appropriate values in the\nDCB structure pointed to by lpDCB. The string must have the same form as the mode command's command-line arguments: COMx[:][baud=b][parity=p][data=d][stop=s][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}] The device name is optional, but it must specify a valid device if used. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: baud=1200 parity=N data=8 stop=1 [out] lpDCB A pointer to a\nDCB structure that receives the information.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BuildCommDCBAndTimeoutsA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-buildcommdcbandtimeoutsa",
            "description": "",
            "parameters": [
                {
                    "name": "lpDef",
                    "type": "LPCSTR",
                    "description": "The device-control information. The function takes this string, parses it, and then sets appropriate values\nin the DCB structure pointed to by\nlpDCB. The string must have the same form as the mode command's command-line arguments: COMx[:][baud={11|110|15|150|30|300|60|600|12|1200|24|2400|48|4800|96|9600|19|19200}][parity={n|e|o|m|s}][data={5|6|7|8}][stop={1|1.5|2}][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}] The \"baud\" substring can be any of the values listed, which are in pairs. The two-digit\nvalues are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19\nrepresents 19,200 baud. The \"parity\" substring indicates how the parity bit is used to detect transmission errors.\nThe values represent \"none\", \"even\", \"odd\",\n\"mark\", and \"space\". For more information, see the Mode command\nreference in TechNet. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: baud=1200 parity=N data=8 stop=1 [out] lpDCB A pointer to a DCB structure that receives information\nfrom the device-control information string pointed to by lpDef. This\nDCB structure defines the control settings for a\ncommunications device. [out] lpCommTimeouts A pointer to a COMMTIMEOUTS structure that\nreceives time-out information.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpCommTimeouts",
                    "type": "LPCOMMTIMEOUTS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BuildCommDCBAndTimeoutsW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-buildcommdcbandtimeoutsw",
            "description": "",
            "parameters": [
                {
                    "name": "lpDef",
                    "type": "LPCWSTR",
                    "description": "The device-control information. The function takes this string, parses it, and then sets appropriate values\nin the DCB structure pointed to by\nlpDCB. The string must have the same form as the mode command's command-line arguments: COMx[:][baud={11|110|15|150|30|300|60|600|12|1200|24|2400|48|4800|96|9600|19|19200}][parity={n|e|o|m|s}][data={5|6|7|8}][stop={1|1.5|2}][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}] The \"baud\" substring can be any of the values listed, which are in pairs. The two-digit\nvalues are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19\nrepresents 19,200 baud. The \"parity\" substring indicates how the parity bit is used to detect transmission errors.\nThe values represent \"none\", \"even\", \"odd\",\n\"mark\", and \"space\". For more information, see the Mode command\nreference in TechNet. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: baud=1200 parity=N data=8 stop=1 [out] lpDCB A pointer to a DCB structure that receives information\nfrom the device-control information string pointed to by lpDef. This\nDCB structure defines the control settings for a\ncommunications device. [out] lpCommTimeouts A pointer to a COMMTIMEOUTS structure that\nreceives time-out information.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpCommTimeouts",
                    "type": "LPCOMMTIMEOUTS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "BuildCommDCBW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-buildcommdcbw",
            "description": "",
            "parameters": [
                {
                    "name": "lpDef",
                    "type": "LPCWSTR",
                    "description": "The device-control information. The function takes this string, parses it, and then sets appropriate values in the\nDCB structure pointed to by lpDCB. The string must have the same form as the mode command's command-line arguments: COMx[:][baud=b][parity=p][data=d][stop=s][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}] The device name is optional, but it must specify a valid device if used. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: baud=1200 parity=N data=8 stop=1 [out] lpDCB A pointer to a\nDCB structure that receives the information.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CallNamedPipeA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-callnamedpipea",
            "description": "",
            "parameters": [
                {
                    "name": "lpNamedPipeName",
                    "type": "LPCSTR",
                    "description": "The pipe name.",
                    "possible_constants": []
                },
                {
                    "name": "lpInBuffer",
                    "type": "LPVOID",
                    "description": "The data to be written to the pipe.",
                    "possible_constants": []
                },
                {
                    "name": "nInBufferSize",
                    "type": "DWORD",
                    "description": "The size of the write buffer, in bytes. [out] lpOutBuffer A pointer to the buffer that receives the data read from the pipe.",
                    "possible_constants": []
                },
                {
                    "name": "lpOutBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nOutBufferSize",
                    "type": "DWORD",
                    "description": "The size of the read buffer, in bytes. [out] lpBytesRead A pointer to a variable that receives the number of bytes read from the pipe.",
                    "possible_constants": []
                },
                {
                    "name": "lpBytesRead",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nTimeOut",
                    "type": "DWORD",
                    "description": "The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CheckNameLegalDOS8Dot3A",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-checknamelegaldos8dot3a",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The file name, in 8.3 format. [out, optional] lpOemName A pointer to a buffer that receives the OEM string that corresponds to Name. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpOemName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "OemNameSize",
                    "type": "DWORD",
                    "description": "The size of the lpOemName buffer, in characters. If\nlpOemName is NULL, this parameter must be 0 (zero). [out, optional] pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be NULL. If\nthe name is not a valid 8.3 FAT file system name, this parameter is undefined. [out] pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when\nthe current OEM code page is applied to the file name.",
                    "possible_constants": []
                },
                {
                    "name": "pbNameContainsSpaces",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pbNameLegal",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CheckNameLegalDOS8Dot3W",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-checknamelegaldos8dot3w",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "The file name, in 8.3 format. [out, optional] lpOemName A pointer to a buffer that receives the OEM string that corresponds to Name. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpOemName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "OemNameSize",
                    "type": "DWORD",
                    "description": "The size of the lpOemName buffer, in characters. If\nlpOemName is NULL, this parameter must be 0 (zero). [out, optional] pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be NULL. If\nthe name is not a valid 8.3 FAT file system name, this parameter is undefined. [out] pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when\nthe current OEM code page is applied to the file name.",
                    "possible_constants": []
                },
                {
                    "name": "pbNameContainsSpaces",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pbNameLegal",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ClearCommBreak",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-clearcommbreak",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ClearCommError",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-clearcommerror",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out, optional] lpErrors A pointer to a variable that receives a mask indicating the type of error. This parameter can be one or more of the following values. The following values are not supported: [out, optional] lpStat A pointer to a\nCOMSTAT structure in which the device's status information is returned. If this parameter is NULL, no status information is returned.",
                    "possible_constants": []
                },
                {
                    "name": "lpErrors",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpStat",
                    "type": "LPCOMSTAT",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ClearEventLogA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-cleareventloga",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log to be cleared. The OpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCSTR",
                    "description": "The absolute or relative path of the backup file. If this file already exists, the function fails. If the lpBackupFileName parameter is NULL, the event log is not backed up.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ClearEventLogW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-cleareventlogw",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log to be cleared. The OpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCWSTR",
                    "description": "The absolute or relative path of the backup file. If this file already exists, the function fails. If the lpBackupFileName parameter is NULL, the event log is not backed up.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CloseEncryptedFileRaw",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-closeencryptedfileraw",
            "description": "",
            "parameters": [
                {
                    "name": "pvContext",
                    "type": "PVOID",
                    "description": "A pointer to a system-defined context block. The\nOpenEncryptedFileRaw function returns the context block.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CloseEventLog",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-closeeventlog",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log to be closed. The\nOpenEventLog or\nOpenBackupEventLog function returns this handle.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CommConfigDialogA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-commconfigdialoga",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCSTR",
                    "description": "The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.",
                    "possible_constants": []
                },
                {
                    "name": "hWnd",
                    "type": "HWND",
                    "description": "A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be NULL if the dialog box is to have no owner.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "A pointer to a\nCOMMCONFIG structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CommConfigDialogW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-commconfigdialogw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCWSTR",
                    "description": "The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.",
                    "possible_constants": []
                },
                {
                    "name": "hWnd",
                    "type": "HWND",
                    "description": "A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be NULL if the dialog box is to have no owner.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "A pointer to a\nCOMMCONFIG structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ConvertFiberToThread",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertfibertothread",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "ConvertThreadToFiber",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber",
            "description": "",
            "parameters": [
                {
                    "name": "lpParameter",
                    "type": "LPVOID",
                    "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the\nGetFiberData macro.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ConvertThreadToFiberEx",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiberex",
            "description": "",
            "parameters": [
                {
                    "name": "lpParameter",
                    "type": "LPVOID",
                    "description": "A  pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the\nGetFiberData macro.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyContext",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copycontext",
            "description": "",
            "parameters": [
                {
                    "name": "Destination",
                    "type": "PCONTEXT",
                    "description": "A pointer to a CONTEXT structure that receives the\ncontext copied from the Source. The\nCONTEXT structure should be initialized by calling\nInitializeContext before calling this\nfunction.",
                    "possible_constants": []
                },
                {
                    "name": "ContextFlags",
                    "type": "DWORD",
                    "description": "Flags specifying the pieces of the Source\nCONTEXT structure that will be copied into the\ndestination. This must be a subset of the ContextFlags specified when calling\nInitializeContext on the\nDestination CONTEXT.",
                    "possible_constants": []
                },
                {
                    "name": "Source",
                    "type": "PCONTEXT",
                    "description": "A pointer to a CONTEXT structure from which to copy\nprocessor context data.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFile",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfile",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCTSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist,\nCopyFile fails, and\nGetLastError returns\nERROR_FILE_NOT_FOUND.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "bFailIfExists",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE and the new file specified by\nlpNewFileName already exists, the function fails. If this parameter is\nFALSE and the new file already exists, the function overwrites the existing file and\nsucceeds.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFile2",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfile2",
            "description": "",
            "parameters": [
                {
                    "name": "pwszExistingFileName",
                    "type": "PCWSTR",
                    "description": "The name of an existing file. To extend this limit to 32,767 wide characters, prepend \"\\?\" to the path. For more\ninformation, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "pwszNewFileName",
                    "type": "PCWSTR",
                    "description": "The name of the new file. To extend this limit to 32,767 wide characters, prepend \"\\?\" to the path. For more\ninformation, see Naming Files, Paths, and Namespaces. [in, optional] pExtendedParameters Optional address of a\nCOPYFILE2_EXTENDED_PARAMETERS\nstructure.",
                    "possible_constants": []
                },
                {
                    "name": "*pExtendedParameters",
                    "type": "COPYFILE2_EXTENDED_PARAMETERS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist,\nCopyFile fails, and\nGetLastError returns\nERROR_FILE_NOT_FOUND.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "bFailIfExists",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE and the new file specified by\nlpNewFileName already exists, the function fails. If this parameter is\nFALSE and the new file already exists, the function overwrites the existing file and\nsucceeds.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileExA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfileexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist, the\nCopyFileEx function fails, and the\nGetLastError function returns\nERROR_FILE_NOT_FOUND.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called\neach time another portion of the file has been copied. This parameter can be NULL. For\nmore information on the progress callback function, see the\nCopyProgressRoutine function.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "The argument to be passed to the callback function. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "pbCancel",
                    "type": "LPBOOL",
                    "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.\nOtherwise, the copy operation will continue to completion.",
                    "possible_constants": []
                },
                {
                    "name": "dwCopyFlags",
                    "type": "DWORD",
                    "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following\nvalues.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfileexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist, the\nCopyFileEx function fails, and the\nGetLastError function returns\nERROR_FILE_NOT_FOUND.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called\neach time another portion of the file has been copied. This parameter can be NULL. For\nmore information on the progress callback function, see the\nCopyProgressRoutine function.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "The argument to be passed to the callback function. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "pbCancel",
                    "type": "LPBOOL",
                    "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.\nOtherwise, the copy operation will continue to completion.",
                    "possible_constants": []
                },
                {
                    "name": "dwCopyFlags",
                    "type": "DWORD",
                    "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following\nvalues.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfiletransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist, the\nCopyFileTransacted function fails, and the\nGetLastError function returns\nERROR_FILE_NOT_FOUND. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called\neach time another portion of the file has been copied. This parameter can be NULL. For\nmore information on the progress callback function, see the\nCopyProgressRoutine function.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "The argument to be passed to the callback function. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "pbCancel",
                    "type": "LPBOOL",
                    "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.\nOtherwise, the copy operation will continue to completion.",
                    "possible_constants": []
                },
                {
                    "name": "dwCopyFlags",
                    "type": "DWORD",
                    "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following\nvalues.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfiletransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist, the\nCopyFileTransacted function fails, and the\nGetLastError function returns\nERROR_FILE_NOT_FOUND. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "The address of a callback function of type LPPROGRESS_ROUTINE that is called\neach time another portion of the file has been copied. This parameter can be NULL. For\nmore information on the progress callback function, see the\nCopyProgressRoutine function.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "The argument to be passed to the callback function. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "pbCancel",
                    "type": "LPBOOL",
                    "description": "If this flag is set to TRUE during the copy operation, the operation is canceled.\nOtherwise, the copy operation will continue to completion.",
                    "possible_constants": []
                },
                {
                    "name": "dwCopyFlags",
                    "type": "DWORD",
                    "description": "Flags that specify how the file is to be copied. This parameter can be a combination of the following\nvalues.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CopyFileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of an existing file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. If lpExistingFileName does not exist,\nCopyFile fails, and\nGetLastError returns\nERROR_FILE_NOT_FOUND.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the new file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "bFailIfExists",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE and the new file specified by\nlpNewFileName already exists, the function fails. If this parameter is\nFALSE and the new file already exists, the function overwrites the existing file and\nsucceeds.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateActCtxA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createactctxa",
            "description": "",
            "parameters": [
                {
                    "name": "pActCtx",
                    "type": "PCACTCTXA",
                    "description": "Pointer to an\nACTCTX structure that contains information about the activation context to be created.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateActCtxW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createactctxw",
            "description": "",
            "parameters": [
                {
                    "name": "pActCtx",
                    "type": "PCACTCTXW",
                    "description": "Pointer to an\nACTCTX structure that contains information about the activation context to be created.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateBoundaryDescriptorA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createboundarydescriptora",
            "description": "",
            "parameters": [
                {
                    "name": "Name",
                    "type": "LPCSTR",
                    "description": "The name of the boundary descriptor.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "ULONG",
                    "description": "A combination of the following flags that are combined by using a bitwise OR operation.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateDirectory",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createdirectory",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCTSTR",
                    "description": "The path of the directory to be created. For the ANSI version of this function, there is a default string size limit for paths of 248 characters (MAX_PATH - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend\n\"\\?\" to the path. For more information, see\nNaming a File",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. The lpSecurityDescriptor member of the structure specifies a security\ndescriptor for the new directory. If lpSecurityAttributes is\nNULL, the directory gets a default security descriptor. The ACLs in the default\nsecurity descriptor for a  directory are inherited from its parent directory. The target file system must support security on files and directories for this parameter to have an effect.\n(This is indicated when GetVolumeInformation\nreturns FS_PERSISTENT_ACLS.)",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateDirectoryExA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createdirectoryexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpTemplateDirectory",
                    "type": "LPCSTR",
                    "description": "The path of the directory to use as a template when creating the new directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewDirectory",
                    "type": "LPCSTR",
                    "description": "The path of the directory to be created. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. The lpSecurityDescriptor member of the structure specifies a security\ndescriptor for the new directory. If lpSecurityAttributes is NULL, the directory gets a\ndefault security descriptor. The access control lists (ACL) in the default security descriptor for a directory\nare inherited from its parent directory. The target file system must support security on files and directories for this parameter to have an effect.\nThis is indicated when GetVolumeInformation\nreturns FS_PERSISTENT_ACLS.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateDirectoryExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createdirectoryexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpTemplateDirectory",
                    "type": "LPCWSTR",
                    "description": "The path of the directory to use as a template when creating the new directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewDirectory",
                    "type": "LPCWSTR",
                    "description": "The path of the directory to be created. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. The lpSecurityDescriptor member of the structure specifies a security\ndescriptor for the new directory. If lpSecurityAttributes is NULL, the directory gets a\ndefault security descriptor. The access control lists (ACL) in the default security descriptor for a directory\nare inherited from its parent directory. The target file system must support security on files and directories for this parameter to have an effect.\nThis is indicated when GetVolumeInformation\nreturns FS_PERSISTENT_ACLS.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateDirectoryTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createdirectorytransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpTemplateDirectory",
                    "type": "LPCSTR",
                    "description": "The path of the directory to use as a template when creating the new directory.  This parameter can be\nNULL. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The directory must reside on the local computer; otherwise, the function fails and the last error code is set\nto ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewDirectory",
                    "type": "LPCSTR",
                    "description": "The path of the directory to be created. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. The lpSecurityDescriptor member of the structure specifies a security\ndescriptor for the new directory. If lpSecurityAttributes is NULL, the directory gets a\ndefault security descriptor. The access control lists (ACL) in the default security descriptor for a directory\nare inherited from its parent directory. The target file system must support security on files and directories for this parameter to have an effect.\nThis is indicated when GetVolumeInformation\nreturns FS_PERSISTENT_ACLS.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateDirectoryTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createdirectorytransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpTemplateDirectory",
                    "type": "LPCWSTR",
                    "description": "The path of the directory to use as a template when creating the new directory.  This parameter can be\nNULL.. The directory must reside on the local computer; otherwise, the function fails and the last error code is set\nto ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewDirectory",
                    "type": "LPCWSTR",
                    "description": "The path of the directory to be created. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. The lpSecurityDescriptor member of the structure specifies a security\ndescriptor for the new directory. If lpSecurityAttributes is NULL, the directory gets a\ndefault security descriptor. The access control lists (ACL) in the default security descriptor for a directory\nare inherited from its parent directory. The target file system must support security on files and directories for this parameter to have an effect.\nThis is indicated when GetVolumeInformation\nreturns FS_PERSISTENT_ACLS.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFiber",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiber",
            "description": "",
            "parameters": [
                {
                    "name": "dwStackSize",
                    "type": "SIZE_T",
                    "description": "The initial committed size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see Thread Stack Size.",
                    "possible_constants": []
                },
                {
                    "name": "lpStartAddress",
                    "type": "LPFIBER_START_ROUTINE",
                    "description": "A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the\nSwitchToFiber function with this address. For more information of the fiber callback function, see\nFiberProc.",
                    "possible_constants": []
                },
                {
                    "name": "lpParameter",
                    "type": "LPVOID",
                    "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the\nGetFiberData macro.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFiberEx",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiberex",
            "description": "",
            "parameters": [
                {
                    "name": "dwStackCommitSize",
                    "type": "SIZE_T",
                    "description": "The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see Thread Stack Size.",
                    "possible_constants": []
                },
                {
                    "name": "dwStackReserveSize",
                    "type": "SIZE_T",
                    "description": "The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default reserved stack size for the executable. For more information, see Thread Stack Size.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber. Windows\u00a0XP:\u00a0\u00a0The FIBER_FLAG_FLOAT_SWITCH flag is not supported.",
                    "possible_constants": []
                },
                {
                    "name": "lpStartAddress",
                    "type": "LPFIBER_START_ROUTINE",
                    "description": "A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the\nSwitchToFiber function with this address. For more information on the fiber callback function, see\nFiberProc.",
                    "possible_constants": []
                },
                {
                    "name": "lpParameter",
                    "type": "LPVOID",
                    "description": "A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the\nGetFiberData macro.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFileMappingA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file from which to create a file mapping object. The file must be opened with access rights that are compatible with the protection flags that the\nflProtect parameter specifies. It is not required, but it is recommended that files\nyou intend to map be opened for exclusive access. For more information, see\nFile Security and Access Rights. If hFile is INVALID_HANDLE_VALUE, the calling process\nmust also specify a size for the file mapping object in the dwMaximumSizeHigh and\ndwMaximumSizeLow parameters. In this scenario,\nCreateFileMapping creates a file mapping object\nof a specified size  that is backed by the system paging file instead of by a file in the file system.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileMappingAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure that determines whether a returned handle can be inherited by child processes. The\nlpSecurityDescriptor member of the\nSECURITY_ATTRIBUTES structure specifies a\nsecurity descriptor for a new file mapping object. If lpFileMappingAttributes is NULL, the handle cannot be inherited\nand the file mapping object gets a default security descriptor. The access control lists (ACL) in the default\nsecurity descriptor for a file mapping object come from the primary or impersonation token of the creator. For\nmore information, see\nFile Mapping Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "flProtect",
                    "type": "DWORD",
                    "description": "Specifies the page protection of the file mapping object. All mapped views of the object must be compatible\nwith this protection. This parameter can be one of the following values. An application can specify one or more of the following attributes for the file mapping object by combining\nthem with one of the preceding page protection values.",
                    "possible_constants": []
                },
                {
                    "name": "dwMaximumSizeHigh",
                    "type": "DWORD",
                    "description": "The high-order DWORD of the maximum size of the file mapping object.",
                    "possible_constants": []
                },
                {
                    "name": "dwMaximumSizeLow",
                    "type": "DWORD",
                    "description": "The low-order DWORD of the maximum size of the file mapping object. If this parameter and dwMaximumSizeHigh are 0 (zero), the maximum size of the file\nmapping object is equal to the current size of the file that  hFile identifies. An attempt to map a file with a length of 0 (zero) fails with an error code of\nERROR_FILE_INVALID. Applications should test for files with a length of 0 (zero) and\nreject those files.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the file mapping object. If this parameter matches the name of an existing mapping object, the function requests access to the\nobject with the protection that flProtect specifies. If this parameter is NULL, the file mapping object is created without a name. If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or\njob object, the function fails, and the GetLastError\nfunction returns ERROR_INVALID_HANDLE. This occurs because these objects share the\nsame namespace. The name can have a \"Global\" or \"Local\" prefix to explicitly create the\nobject in the global or session namespace. The remainder of the name can contain any character except the\nbackslash character (\\). Creating a file mapping object in the global namespace from a session other than\nsession zero requires the\nSeCreateGlobalPrivilege\nprivilege. For more information, see\nKernel Object Namespaces. Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session\n0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the\nguidelines that are outlined for Terminal Services so that applications can support multiple users.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFileMappingNumaA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappingnumaa",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file from which to create a file mapping object. The file must be opened with access\nrights that are compatible with the protection flags that the flProtect parameter\nspecifies. It is not required, but it is recommended that files you intend to map be opened for exclusive\naccess. For more information, see\nFile Security and Access Rights. If hFile is INVALID_HANDLE_VALUE, the calling process\nmust also specify a size for the file mapping object in the dwMaximumSizeHigh and\ndwMaximumSizeLow parameters. In this scenario,\nCreateFileMappingNuma creates a file mapping\nobject of a specified size  that is backed by the system paging file instead of by a file in the file\nsystem.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileMappingAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure that determines whether a returned handle can be inherited by child processes. The\nlpSecurityDescriptor member of the\nSECURITY_ATTRIBUTES structure specifies a\nsecurity descriptor for a new file mapping object. If lpFileMappingAttributes is NULL, the handle cannot be\ninherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the\ndefault security descriptor for a file mapping object come from the primary or impersonation token of the\ncreator. For more information, see\nFile Mapping Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "flProtect",
                    "type": "DWORD",
                    "description": "Specifies the page protection of the file mapping object. All mapped views of the object must be compatible\nwith this protection. This parameter can be one of the following values. An application can specify one or more of the following attributes for the file mapping object by combining\nthem with one of the preceding page protection values.",
                    "possible_constants": []
                },
                {
                    "name": "dwMaximumSizeHigh",
                    "type": "DWORD",
                    "description": "The high-order DWORD of the maximum size of the file mapping object.",
                    "possible_constants": []
                },
                {
                    "name": "dwMaximumSizeLow",
                    "type": "DWORD",
                    "description": "The low-order DWORD of the maximum size of the file mapping object. If this parameter and the dwMaximumSizeHigh parameter are 0 (zero), the maximum\nsize of the file mapping object is equal to the current size of the file that the\nhFile parameter identifies. An attempt to map a file with a length of 0 (zero) fails with an error code of\nERROR_FILE_INVALID. Applications should test for files with a length of 0 (zero) and\nreject those files.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the file mapping object. If this parameter matches the name of an existing file mapping object, the function requests access to the\nobject with the protection that the flProtect parameter specifies. If this parameter is NULL, the file mapping object is created without a name. If the lpName parameter matches the name of an existing event, semaphore, mutex,\nwaitable timer, or job object, the function fails and the\nGetLastError function returns\nERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\" or \"Local\" prefix to explicitly create the\nobject in the global or session namespace. The remainder of the name can contain any character except the\nbackslash character (\\). Creating a file mapping object in the global namespace requires the\nSeCreateGlobalPrivilege\nprivilege. For more information, see\nKernel Object Namespaces. Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses\nsession 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the\nguidelines so that applications can support multiple users.",
                    "possible_constants": []
                },
                {
                    "name": "nndPreferred",
                    "type": "DWORD",
                    "description": "The NUMA node where the physical memory should reside.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFileTransactedA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiletransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of an object to be created or opened. The object must reside on the local computer; otherwise,\nthe function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more\ninformation, see File Streams.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly\nused values are GENERIC_READ, GENERIC_WRITE, or both\n(GENERIC_READ | GENERIC_WRITE). For more information, see\nGeneric Access Rights and\nFile Security and Access Rights. If this parameter is zero, the application can query  file, directory, or device attributes without accessing\nthat file or device. For more information, see the Remarks section of this topic. You cannot request an access mode that conflicts with the sharing mode that is specified in an open request\nthat has an open handle. For more information, see\nCreating and Opening Files.",
                    "possible_constants": []
                },
                {
                    "name": "dwShareMode",
                    "type": "DWORD",
                    "description": "The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the\nfollowing table). If this parameter is zero and\nCreateFileTransacted succeeds, the object cannot\nbe shared and cannot be opened again until the handle is closed. For more information, see the Remarks section\nof this topic. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request\nthat has an open handle, because that would result in the following sharing violation:\nERROR_SHARING_VIOLATION. For more information, see\nCreating and Opening Files. To enable a process to share an object while another process has the object open, use a combination of one or\nmore of the following values to specify the  access mode they can request to open the object.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure that contains an optional\nsecurity descriptor and also determines whether\nor not the returned handle can be inherited by child processes. The parameter can be\nNULL. If the lpSecurityAttributes parameter is NULL, the handle\nreturned by CreateFileTransacted cannot be\ninherited by any child processes your application may create and the object associated with the returned handle\ngets a default security descriptor. The bInheritHandle member of the structure specifies whether the returned handle\ncan be inherited. The  lpSecurityDescriptor member of the structure specifies\na security descriptor for an object, but may\nalso be NULL. If lpSecurityDescriptor member is NULL, the object\nassociated with the returned handle is assigned a default security descriptor. CreateFileTransacted ignores the\nlpSecurityDescriptor member when opening an existing file, but continues to use the\nbInheritHandle member. For more information, see the Remarks section of this topic.",
                    "possible_constants": []
                },
                {
                    "name": "dwCreationDisposition",
                    "type": "DWORD",
                    "description": "An action to take on files that exist and  do not exist. For more information, see the Remarks section of this topic. This parameter must be one of the following values, which cannot be combined.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlagsAndAttributes",
                    "type": "DWORD",
                    "description": "The file attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default\nvalue. This parameter can include any combination of the available file attributes\n(FILE_ATTRIBUTE_*). All other file attributes override\nFILE_ATTRIBUTE_NORMAL. This parameter can also contain combinations of flags (FILE_FLAG_) for control of\nbuffering behavior, access modes, and other special-purpose flags. These combine with any\nFILE_ATTRIBUTE_ values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the\nSECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in\nthe table following the attributes and flags tables. The dwFlagsAndAttributes parameter can also specify Security Quality of Service\ninformation. For more information, see\nImpersonation Levels. When the calling\napplication specifies the SECURITY_SQOS_PRESENT flag as part of\ndwFlagsAndAttributes, it can also contain one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "hTemplateFile",
                    "type": "HANDLE",
                    "description": "A valid handle to a template file with the GENERIC_READ access right. The template\nfile supplies file attributes and extended attributes for the file that is being created. This parameter can be\nNULL. When opening an existing file,\nCreateFileTransacted ignores the template\nfile. When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                },
                {
                    "name": "pusMiniVersion",
                    "type": "PUSHORT",
                    "description": "The miniversion to be opened. If the transaction specified in hTransaction is not\nthe transaction that is modifying the file, this parameter should be NULL. Otherwise,\nthis parameter can be a miniversion identifier returned by the\nFSCTL_TXFS_CREATE_MINIVERSION control\ncode, or one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpExtendedParameter",
                    "type": "PVOID",
                    "description": " This parameter is reserved and must be NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateFileTransactedW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiletransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of an object to be created or opened. The object must reside on the local computer; otherwise,\nthe function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more\ninformation, see File Streams.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly\nused values are GENERIC_READ, GENERIC_WRITE, or both\n(GENERIC_READ | GENERIC_WRITE). For more information, see\nGeneric Access Rights and\nFile Security and Access Rights. If this parameter is zero, the application can query  file, directory, or device attributes without accessing\nthat file or device. For more information, see the Remarks section of this topic. You cannot request an access mode that conflicts with the sharing mode that is specified in an open request\nthat has an open handle. For more information, see\nCreating and Opening Files.",
                    "possible_constants": []
                },
                {
                    "name": "dwShareMode",
                    "type": "DWORD",
                    "description": "The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the\nfollowing table). If this parameter is zero and\nCreateFileTransacted succeeds, the object cannot\nbe shared and cannot be opened again until the handle is closed. For more information, see the Remarks section\nof this topic. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request\nthat has an open handle, because that would result in the following sharing violation:\nERROR_SHARING_VIOLATION. For more information, see\nCreating and Opening Files. To enable a process to share an object while another process has the object open, use a combination of one or\nmore of the following values to specify the  access mode they can request to open the object.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure that contains an optional\nsecurity descriptor and also determines whether\nor not the returned handle can be inherited by child processes. The parameter can be\nNULL. If the lpSecurityAttributes parameter is NULL, the handle\nreturned by CreateFileTransacted cannot be\ninherited by any child processes your application may create and the object associated with the returned handle\ngets a default security descriptor. The bInheritHandle member of the structure specifies whether the returned handle\ncan be inherited. The  lpSecurityDescriptor member of the structure specifies\na security descriptor for an object, but may\nalso be NULL. If lpSecurityDescriptor member is NULL, the object\nassociated with the returned handle is assigned a default security descriptor. CreateFileTransacted ignores the\nlpSecurityDescriptor member when opening an existing file, but continues to use the\nbInheritHandle member. For more information, see the Remarks section of this topic.",
                    "possible_constants": []
                },
                {
                    "name": "dwCreationDisposition",
                    "type": "DWORD",
                    "description": "An action to take on files that exist and  do not exist. For more information, see the Remarks section of this topic. This parameter must be one of the following values, which cannot be combined.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlagsAndAttributes",
                    "type": "DWORD",
                    "description": "The file attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common default\nvalue. This parameter can include any combination of the available file attributes\n(FILE_ATTRIBUTE_*). All other file attributes override\nFILE_ATTRIBUTE_NORMAL. This parameter can also contain combinations of flags (FILE_FLAG_) for control of\nbuffering behavior, access modes, and other special-purpose flags. These combine with any\nFILE_ATTRIBUTE_ values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the\nSECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in\nthe table following the attributes and flags tables. The dwFlagsAndAttributes parameter can also specify Security Quality of Service\ninformation. For more information, see\nImpersonation Levels. When the calling\napplication specifies the SECURITY_SQOS_PRESENT flag as part of\ndwFlagsAndAttributes, it can also contain one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "hTemplateFile",
                    "type": "HANDLE",
                    "description": "A valid handle to a template file with the GENERIC_READ access right. The template\nfile supplies file attributes and extended attributes for the file that is being created. This parameter can be\nNULL. When opening an existing file,\nCreateFileTransacted ignores the template\nfile. When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                },
                {
                    "name": "pusMiniVersion",
                    "type": "PUSHORT",
                    "description": "The miniversion to be opened. If the transaction specified in hTransaction is not\nthe transaction that is modifying the file, this parameter should be NULL. Otherwise,\nthis parameter can be a miniversion identifier returned by the\nFSCTL_TXFS_CREATE_MINIVERSION control\ncode, or one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpExtendedParameter",
                    "type": "PVOID",
                    "description": " This parameter is reserved and must be NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateHardLinkA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinka",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the new file. This parameter may include the path but cannot specify the name of a directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of the existing file. This parameter may include the path cannot specify the name of a directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": " Reserved; must be NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateHardLinkTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinktransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the new file. This parameter cannot specify the name of a directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of the existing file. This parameter cannot specify the name of a directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": " Reserved; must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateHardLinkTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinktransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the new file. This parameter cannot specify the name of a directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the existing file. This parameter cannot specify the name of a directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": " Reserved; must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateHardLinkW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createhardlinkw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the new file. This parameter may include the path but cannot specify the name of a directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the existing file. This parameter may include the path cannot specify the name of a directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": " Reserved; must be NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateJobObjectA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createjobobjecta",
            "description": "",
            "parameters": [
                {
                    "name": "lpJobAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a\nSECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If lpJobAttributes is NULL, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the job. The name is limited to MAX_PATH characters. Name comparison is case-sensitive. If lpName is NULL, the job is created without a name. If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the\nGetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The object can be created in a private namespace. For more information, see Object Namespaces. Terminal Services:\u00a0\u00a0The name can have a \"Global\" or \"Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see\nKernel Object Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateMailslotA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createmailslota",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the mailslot. This name must have the following form: \\\\.\\mailslot\\[path]name The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\\\.\\mailslot\\example_mailslot_name and \\\\.\\mailslot\\abc\\def\\ghi are valid names.",
                    "possible_constants": []
                },
                {
                    "name": "nMaxMessageSize",
                    "type": "DWORD",
                    "description": "The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.",
                    "possible_constants": []
                },
                {
                    "name": "lReadTimeout",
                    "type": "DWORD",
                    "description": "The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings. This time-out value applies to all subsequent read operations and all inherited mailslot handles.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a\nSECURITY_ATTRIBUTES structure. The bInheritHandle member of the structure determines whether the returned handle can be inherited by child processes. If lpSecurityAttributes is NULL, the handle cannot be inherited.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateMailslotW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createmailslotw",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "The name of the mailslot. This name must have the following form: \\\\.\\mailslot\\[path]name The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\\\.\\mailslot\\example_mailslot_name and \\\\.\\mailslot\\abc\\def\\ghi are valid names.",
                    "possible_constants": []
                },
                {
                    "name": "nMaxMessageSize",
                    "type": "DWORD",
                    "description": "The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.",
                    "possible_constants": []
                },
                {
                    "name": "lReadTimeout",
                    "type": "DWORD",
                    "description": "The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings. This time-out value applies to all subsequent read operations and all inherited mailslot handles.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a\nSECURITY_ATTRIBUTES structure. The bInheritHandle member of the structure determines whether the returned handle can be inherited by child processes. If lpSecurityAttributes is NULL, the handle cannot be inherited.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateNamedPipeA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The unique pipe name. This string must have the following form: \\\\.\\pipe\\pipename The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.",
                    "possible_constants": []
                },
                {
                    "name": "dwOpenMode",
                    "type": "DWORD",
                    "description": "The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags listed in the following tables. This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe. This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe. This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.",
                    "possible_constants": []
                },
                {
                    "name": "dwPipeMode",
                    "type": "DWORD",
                    "description": "The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags listed in the following tables. One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe. One of the following read modes can be specified. Different instances of the same pipe can specify different read modes. One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes. One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.",
                    "possible_constants": []
                },
                {
                    "name": "nMaxInstances",
                    "type": "DWORD",
                    "description": "The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through PIPE_UNLIMITED_INSTANCES (255). If this parameter is PIPE_UNLIMITED_INSTANCES, the number of pipe instances that can be created is limited only by the availability of system resources. If nMaxInstances is greater than PIPE_UNLIMITED_INSTANCES, the return value is INVALID_HANDLE_VALUE and GetLastError returns ERROR_INVALID_PARAMETER.",
                    "possible_constants": []
                },
                {
                    "name": "nOutBufferSize",
                    "type": "DWORD",
                    "description": "The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.",
                    "possible_constants": []
                },
                {
                    "name": "nInBufferSize",
                    "type": "DWORD",
                    "description": "The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.",
                    "possible_constants": []
                },
                {
                    "name": "nDefaultTimeOut",
                    "type": "DWORD",
                    "description": "The default time-out value, in milliseconds, if the\nWaitNamedPipe function specifies NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value. A value of zero will result in a default time-out of 50 milliseconds.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a\nSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreatePrivateNamespaceA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprivatenamespacea",
            "description": "",
            "parameters": [
                {
                    "name": "lpPrivateNamespaceAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES structure that specifies the security attributes of the namespace object.",
                    "possible_constants": []
                },
                {
                    "name": "lpBoundaryDescriptor",
                    "type": "LPVOID",
                    "description": "A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The CreateBoundaryDescriptor function creates a boundary descriptor.",
                    "possible_constants": []
                },
                {
                    "name": "lpAliasPrefix",
                    "type": "LPCSTR",
                    "description": "The prefix for the namespace. To create an object in this namespace, specify the object name as prefix\\objectname. The system supports multiple private namespaces with the same name, as long as they define different boundaries.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateProcessWithLogonW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw",
            "description": "",
            "parameters": [
                {
                    "name": "lpUsername",
                    "type": "LPCWSTR",
                    "description": "The name of the user. This is the name of the user account to log on to. If you use the UPN format, user@DNS_domain_name, the lpDomain parameter must be NULL. The user account must have the Log On Locally permission on the local computer. This permission is granted to all users on workstations and servers, but only to administrators on domain controllers.",
                    "possible_constants": []
                },
                {
                    "name": "lpDomain",
                    "type": "LPCWSTR",
                    "description": "The name of the domain or server whose account database contains the lpUsername account. If this parameter is NULL, the user name must be specified in UPN format.",
                    "possible_constants": []
                },
                {
                    "name": "lpPassword",
                    "type": "LPCWSTR",
                    "description": "The clear-text password for the lpUsername account.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonFlags",
                    "type": "DWORD",
                    "description": "The logon option. This parameter can be 0 (zero) or one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpApplicationName",
                    "type": "LPCWSTR",
                    "description": "The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The string can specify the full path and file name of the module to execute or it can specify a partial name. If it is a partial name, the function uses the current drive and current directory to complete the specification. The function does not use the search path. This parameter must include the file name extension; no default extension is assumed. The lpApplicationName parameter can be NULL, and the module name must be the first white space\u00e2\u0080\u0093delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, the following string can be interpreted in different ways: \"c:\\program files\\sub dir\\program name\" The system tries to interpret the possibilities in the following order: If the executable module is a 16-bit application, lpApplicationName should be NULL, and the string pointed to by lpCommandLine should specify the executable module and its arguments.",
                    "possible_constants": []
                },
                {
                    "name": "lpCommandLine",
                    "type": "LPWSTR",
                    "description": "The command line to be executed. The maximum length of this string is 1024 characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters. The function can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation. The lpCommandLine parameter can be NULL, and the function uses the string pointed to by lpApplicationName as the command line. If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use\nGetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers typically repeat the module name as the first token in the command line. If lpApplicationName is NULL, the first white space\u00e2\u0080\u0093delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period  with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:",
                    "possible_constants": []
                },
                {
                    "name": "dwCreationFlags",
                    "type": "DWORD",
                    "description": "The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and CREATE_NEW_PROCESS_GROUP flags are enabled by default. For a list of values, see Process Creation Flags. This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see\nGetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process. If the dwCreationFlags parameter has a value of 0:",
                    "possible_constants": []
                },
                {
                    "name": "lpEnvironment",
                    "type": "LPVOID",
                    "description": "A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by lpUsername. An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: name=value Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable. An environment block can contain Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. An ANSI environment block is terminated by two 0 (zero) bytes: one for the last string and one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block. To retrieve a copy of the environment block for a specific user, use the\nCreateEnvironmentBlock function.",
                    "possible_constants": []
                },
                {
                    "name": "lpCurrentDirectory",
                    "type": "LPCWSTR",
                    "description": "The full path to the current directory for the process. The string can also specify a UNC path. If this parameter is NULL, the new process has the same current drive and directory as the calling process. This feature is provided primarily for shells that need to start an application, and specify its initial drive and working directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpStartupInfo",
                    "type": "LPSTARTUPINFOW",
                    "description": "A pointer to a\nSTARTUPINFO structure. The application must add permission for the specified user account to the specified window station and desktop, even for WinSta0\\Default. If the lpDesktop member is NULL or an empty string, the new process inherits the desktop and window station of its parent process.\nThe application must add permission for the specified user account to the inherited window station and desktop. Windows\u00a0XP:\u00a0\u00a0CreateProcessWithLogonW adds permission for the specified user account to the inherited window station and desktop. Handles in\nSTARTUPINFO must be closed with\nCloseHandle when they are no longer needed. [out] lpProcessInformation A pointer to a\nPROCESS_INFORMATION structure that receives identification information for the new process, including a handle to the process. Handles in\nPROCESS_INFORMATION must be closed with the\nCloseHandle function when they are not needed.",
                    "possible_constants": []
                },
                {
                    "name": "lpProcessInformation",
                    "type": "LPPROCESS_INFORMATION",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateProcessWithTokenW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw",
            "description": "",
            "parameters": [
                {
                    "name": "hToken",
                    "type": "HANDLE",
                    "description": "A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see\nAccess Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the lpApplicationName or the lpCommandLine parameter. To get a primary token that represents the specified user, call the\nLogonUser function. Alternatively, you can call the\nDuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client. Terminal Services:\u00a0\u00a0The caller's process always runs in the caller's session, not in the session specified in the token. To run a process in the session specified in the token, use the CreateProcessAsUser function.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonFlags",
                    "type": "DWORD",
                    "description": "The logon option. This parameter can be zero or one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpApplicationName",
                    "type": "LPCWSTR",
                    "description": "The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed. The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space\u00e2\u0080\u0093delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string \"c:\\program files\\sub dir\\program name\". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order: c:\\program.exe\nc:\\program files\\sub.exe\nc:\\program files\\sub dir\\program.exe\nc:\\program files\\sub dir\\program name.exe\nIf the executable module is a 16-bit application, lpApplicationName should be NULL, and the string pointed to by lpCommandLine should specify the executable module as well as its arguments.",
                    "possible_constants": []
                },
                {
                    "name": "lpCommandLine",
                    "type": "LPWSTR",
                    "description": "The command line to be executed. The maximum length of this string is 1024 characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters. The function can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation. The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line. If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use\nGetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line. If lpApplicationName is NULL, the first white space\u00e2\u0080\u0093delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:",
                    "possible_constants": []
                },
                {
                    "name": "dwCreationFlags",
                    "type": "DWORD",
                    "description": "The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and CREATE_NEW_PROCESS_GROUP flags are enabled by default. For a list of values, see Process Creation Flags. This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see\nGetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process. If the dwCreationFlags parameter has a value of 0:",
                    "possible_constants": []
                },
                {
                    "name": "lpEnvironment",
                    "type": "LPVOID",
                    "description": "A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by lpUsername. An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: name=value Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable. An environment block can contain Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. An ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block. To retrieve a copy of the environment block for a specific user, use the\nCreateEnvironmentBlock function.",
                    "possible_constants": []
                },
                {
                    "name": "lpCurrentDirectory",
                    "type": "LPCWSTR",
                    "description": "The full path to the current directory for the process. The string can also specify a UNC path. If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)",
                    "possible_constants": []
                },
                {
                    "name": "lpStartupInfo",
                    "type": "LPSTARTUPINFOW",
                    "description": "A pointer to a\nSTARTUPINFO or STARTUPINFOEX structure. If the lpDesktop member is NULL or an empty string, the new process inherits the desktop and window station of its parent process. The function adds permission for the specified user account to the inherited window station and desktop. Otherwise, if this member specifies a desktop, it is the responsibility of the application to add permission for the specified user account to the specified window station and desktop, even for WinSta0\\Default. Handles in\nSTARTUPINFO or STARTUPINFOEX must be closed with\nCloseHandle when they are no longer needed. [out] lpProcessInformation A pointer to a\nPROCESS_INFORMATION structure that receives identification information for the new process, including a handle to the process. Handles in\nPROCESS_INFORMATION must be closed with the\nCloseHandle function when they are no longer needed.",
                    "possible_constants": []
                },
                {
                    "name": "lpProcessInformation",
                    "type": "LPPROCESS_INFORMATION",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSemaphoreA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea",
            "description": "",
            "parameters": [
                {
                    "name": "lpSemaphoreAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a SECURITY_ATTRIBUTES\nstructure. If this parameter is NULL, the handle cannot be inherited by child\nprocesses. The lpSecurityDescriptor member of the structure specifies a security descriptor\nfor the new semaphore. If this parameter is NULL, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.",
                    "possible_constants": []
                },
                {
                    "name": "lInitialCount",
                    "type": "LONG",
                    "description": "The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to lMaximumCount. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the\nReleaseSemaphore function.",
                    "possible_constants": []
                },
                {
                    "name": "lMaximumCount",
                    "type": "LONG",
                    "description": "The maximum count for the semaphore object. This value must be greater than zero.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the semaphore object. The name is limited to MAX_PATH characters. Name comparison is case sensitive. If lpName matches the name of an existing named semaphore object, this function requests the SEMAPHORE_ALL_ACCESS access right. In this case, the lInitialCount and lMaximumCount parameters are ignored because they have already been set by the creating process. If the lpSemaphoreAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored. If lpName is NULL, the semaphore object is created without a name. If lpName matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the\nGetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\" or \"Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see\nKernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSemaphoreExA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphoreexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpSemaphoreAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "A pointer to a\nSECURITY_ATTRIBUTES structure. If this parameter is NULL, the semaphore handle cannot be inherited by child processes. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new semaphore. If this parameter is NULL, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.",
                    "possible_constants": []
                },
                {
                    "name": "lInitialCount",
                    "type": "LONG",
                    "description": "The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to lMaximumCount. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the\nReleaseSemaphore function.",
                    "possible_constants": []
                },
                {
                    "name": "lMaximumCount",
                    "type": "LONG",
                    "description": "The maximum count for the semaphore object. This value must be greater than zero.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to MAX_PATH characters. Name comparison is case sensitive. If lpName matches the name of an existing named semaphore object, the lInitialCount and lMaximumCount parameters are ignored because they have already been set by the creating process. If the lpSemaphoreAttributes parameter is not NULL, it determines whether the handle can be inherited. If lpName is NULL, the semaphore object is created without a name. If lpName matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the\nGetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace. The name can have a \"Global\" or \"Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see\nKernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be created in a private namespace. For more information, see Object Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": " This parameter is reserved and must be 0.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access mask for the semaphore object. For a list of access rights, see\nSynchronization Object Security and Access Rights.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSymbolicLinkA",
            "return_type": "BOOLEAN",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka",
            "description": "",
            "parameters": [
                {
                    "name": "lpSymlinkFileName",
                    "type": "LPCSTR",
                    "description": "The symbolic link to be created. This parameter may include the path. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetFileName",
                    "type": "LPCSTR",
                    "description": "The name of the target for the symbolic link to be created. If lpTargetFileName has a device name associated with it, the link is treated as\nan absolute link; otherwise, the link is treated as a relative link. This parameter may include the path. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Indicates whether the link target, lpTargetFileName, is a directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSymbolicLinkTransactedA",
            "return_type": "BOOLEAN",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinktransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpSymlinkFileName",
                    "type": "LPCSTR",
                    "description": "The symbolic link to be created.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetFileName",
                    "type": "LPCSTR",
                    "description": "The name of the target for the symbolic link to be created. If lpTargetFileName has a device name associated with it, the link is treated as an\nabsolute link; otherwise, the link is treated as a relative link.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Indicates whether the link target, lpTargetFileName, is a directory.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSymbolicLinkTransactedW",
            "return_type": "BOOLEAN",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinktransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpSymlinkFileName",
                    "type": "LPCWSTR",
                    "description": "The symbolic link to be created.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the target for the symbolic link to be created. If lpTargetFileName has a device name associated with it, the link is treated as an\nabsolute link; otherwise, the link is treated as a relative link.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Indicates whether the link target, lpTargetFileName, is a directory.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateSymbolicLinkW",
            "return_type": "BOOLEAN",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinkw",
            "description": "",
            "parameters": [
                {
                    "name": "lpSymlinkFileName",
                    "type": "LPCWSTR",
                    "description": "The symbolic link to be created. This parameter may include the path. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the target for the symbolic link to be created. If lpTargetFileName has a device name associated with it, the link is treated as\nan absolute link; otherwise, the link is treated as a relative link. This parameter may include the path. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Indicates whether the link target, lpTargetFileName, is a directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateTapePartition",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createtapepartition",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device where the new partition is to be created. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwPartitionMethod",
                    "type": "DWORD",
                    "description": "Type of partition to create. To determine what type of partitions your device supports, see the documentation for your hardware. This parameter can have one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwCount",
                    "type": "DWORD",
                    "description": "Number of partitions to create. The\nGetTapeParameters function provides the maximum number of partitions a tape can support.",
                    "possible_constants": []
                },
                {
                    "name": "dwSize",
                    "type": "DWORD",
                    "description": "Size of each partition, in megabytes. This value is ignored if the dwPartitionMethod parameter is TAPE_SELECT_PARTITIONS.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateUmsCompletionList",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createumscompletionlist",
            "description": "",
            "parameters": [
                {
                    "name": "*UmsCompletionList",
                    "type": "PUMS_COMPLETION_LIST",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "CreateUmsThreadContext",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createumsthreadcontext",
            "description": "",
            "parameters": [
                {
                    "name": "*lpUmsThread",
                    "type": "PUMS_CONTEXT",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeactivateActCtx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deactivateactctx",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Flags that indicate how the deactivation is to occur.",
                    "possible_constants": []
                },
                {
                    "name": "ulCookie",
                    "type": "ULONG_PTR",
                    "description": "The ULONG_PTR that was passed into the call to\nActivateActCtx. This value is used as a cookie to identify a specific activated activation context.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DebugBreakProcess",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-debugbreakprocess",
            "description": "",
            "parameters": [
                {
                    "name": "Process",
                    "type": "HANDLE",
                    "description": "A handle to the process.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DebugSetProcessKillOnExit",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-debugsetprocesskillonexit",
            "description": "",
            "parameters": [
                {
                    "name": "KillOnExit",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the thread terminates all attached processes on exit (note that this is the default). Otherwise, the thread detaches from all processes being debugged on exit.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DecryptFileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-decryptfilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file or directory to be decrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA, FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and SYNCHRONIZE access rights. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwReserved",
                    "type": "DWORD",
                    "description": " Reserved; must be zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DecryptFileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-decryptfilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file or directory to be decrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA, FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and SYNCHRONIZE access rights. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwReserved",
                    "type": "DWORD",
                    "description": " Reserved; must be zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DefineDosDeviceA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-definedosdevicea",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The controllable aspects of the DefineDosDevice function. This parameter\ncan be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpDeviceName",
                    "type": "LPCSTR",
                    "description": "A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or\ndeleting. The device name string must not have a colon as the last character, unless a drive letter is being\ndefined, redefined, or deleted. For example, drive C  would be the string \"C:\". In no case is a\ntrailing backslash (\"\") allowed.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetPath",
                    "type": "LPCSTR",
                    "description": "A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the\nDDD_RAW_TARGET_PATH flag is specified, in which case this string is a path\nstring.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteAtom",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deleteatom",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The atom to be deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteFiber",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletefiber",
            "description": "",
            "parameters": [
                {
                    "name": "lpFiber",
                    "type": "LPVOID",
                    "description": "The address of the fiber to be deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteFile",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletefile",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the file to be deleted. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteFileTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletefiletransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file to be deleted. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteFileTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletefiletransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file to be deleted. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteUmsCompletionList",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deleteumscompletionlist",
            "description": "",
            "parameters": [
                {
                    "name": "UmsCompletionList",
                    "type": "PUMS_COMPLETION_LIST",
                    "description": "A pointer to the UMS completion list to be deleted. The CreateUmsCompletionList function provides this pointer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteUmsThreadContext",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deleteumsthreadcontext",
            "description": "",
            "parameters": [
                {
                    "name": "UmsThread",
                    "type": "PUMS_CONTEXT",
                    "description": "A pointer to the UMS thread context to be deleted. The CreateUmsThreadContext function provides this pointer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeleteVolumeMountPointA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletevolumemountpointa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPCSTR",
                    "description": "The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,\n\"X:\" or \"Y:\\MountX\".",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DequeueUmsCompletionListItems",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dequeueumscompletionlistitems",
            "description": "",
            "parameters": [
                {
                    "name": "UmsCompletionList",
                    "type": "PUMS_COMPLETION_LIST",
                    "description": "A pointer to the completion list from which to retrieve worker threads.",
                    "possible_constants": []
                },
                {
                    "name": "WaitTimeOut",
                    "type": "DWORD",
                    "description": "The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses, even if no worker threads are queued to the completion list. If the WaitTimeOut parameter is zero, the completion list is checked for available worker threads without waiting for worker threads to become available. If the WaitTimeOut parameter is INFINITE, the function's time-out interval never elapses. This is not recommended, however, because it causes the function to block until one or more worker threads become available. [out] UmsThreadList A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context in a list of UMS thread contexts. If no worker threads are available before the time-out specified by the WaitTimeOut parameter, this parameter is set to NULL.",
                    "possible_constants": []
                },
                {
                    "name": "*UmsThreadList",
                    "type": "PUMS_CONTEXT",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DeregisterEventSource",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deregistereventsource",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log. The\nRegisterEventSource function returns this handle.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DestroyThreadpoolEnvironment",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-destroythreadpoolenvironment",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DisableThreadProfiling",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-disablethreadprofiling",
            "description": "",
            "parameters": [
                {
                    "name": "PerformanceDataHandle",
                    "type": "HANDLE",
                    "description": "The handle that the EnableThreadProfiling function returned.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DnsHostnameToComputerNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dnshostnametocomputernamea",
            "description": "",
            "parameters": [
                {
                    "name": "Hostname",
                    "type": "LPCSTR",
                    "description": "The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see Computer Names. [out] ComputerName A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.",
                    "possible_constants": []
                },
                {
                    "name": "ComputerName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "LPDWORD",
                    "description": "On input, specifies the size of the buffer, in TCHARs. On output, receives the number of TCHARs copied to the destination buffer, not including the terminating null character. If the buffer is too small, the function fails, GetLastError returns ERROR_MORE_DATA, and nSize receives the required buffer size, not including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DnsHostnameToComputerNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dnshostnametocomputernamew",
            "description": "",
            "parameters": [
                {
                    "name": "Hostname",
                    "type": "LPCWSTR",
                    "description": "The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see Computer Names. [out] ComputerName A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.",
                    "possible_constants": []
                },
                {
                    "name": "ComputerName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "LPDWORD",
                    "description": "On input, specifies the size of the buffer, in TCHARs. On output, receives the number of TCHARs copied to the destination buffer, not including the terminating null character. If the buffer is too small, the function fails, GetLastError returns ERROR_MORE_DATA, and nSize receives the required buffer size, not including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "DosDateTimeToFileTime",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime",
            "description": "",
            "parameters": [
                {
                    "name": "wFatDate",
                    "type": "WORD",
                    "description": "The MS-DOS date. The date is a packed value with the following format.",
                    "possible_constants": []
                },
                {
                    "name": "wFatTime",
                    "type": "WORD",
                    "description": "The MS-DOS time. The time is a packed value with the following format. [out] lpFileTime A pointer to a\nFILETIME structure that receives the converted file time.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileTime",
                    "type": "LPFILETIME",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnableProcessOptionalXStateFeatures",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enableprocessoptionalxstatefeatures",
            "description": "",
            "parameters": [
                {
                    "name": "Features",
                    "type": "DWORD64",
                    "description": " A bitmask in which each bit represents an optional XState feature to enable for the current process.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnableThreadProfiling",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enablethreadprofiling",
            "description": "",
            "parameters": [
                {
                    "name": "ThreadHandle",
                    "type": "HANDLE",
                    "description": "The handle to the thread on which you want to enable profiling. This must be the current thread.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "To receive thread profiling data such as context switch count, set this parameter to THREAD_PROFILING_FLAG_DISPATCH; otherwise, set to 0.",
                    "possible_constants": []
                },
                {
                    "name": "HardwareCounters",
                    "type": "DWORD64",
                    "description": "To receive hardware performance counter data, set this parameter to a bitmask that identifies the hardware counters to collect. You can specify up to 16 performance counters. Each bit relates directly to the zero-based hardware counter index for the hardware performance counters that you configured. Set to zero if you are not collecting hardware counter data. If you set a bit for a hardware counter that has not been configured, the counter value that is read for that counter is zero. [out] PerformanceDataHandle An opaque handle that you use when calling the ReadThreadProfilingData and DisableThreadProfiling functions.",
                    "possible_constants": []
                },
                {
                    "name": "*PerformanceDataHandle",
                    "type": "HANDLE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EncryptFileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-encryptfilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file or directory to be encrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA,\nFILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and\nSYNCHRONIZE access rights. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EncryptFileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-encryptfilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file or directory to be encrypted. The caller must have the FILE_READ_DATA, FILE_WRITE_DATA,\nFILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES, and\nSYNCHRONIZE access rights. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EndUpdateResourceA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-endupdateresourcea",
            "description": "",
            "parameters": [
                {
                    "name": "hUpdate",
                    "type": "HANDLE",
                    "description": "Type: HANDLE A module handle returned by the BeginUpdateResource function, and used by UpdateResource, referencing the file to be updated.",
                    "possible_constants": []
                },
                {
                    "name": "fDiscard",
                    "type": "BOOL",
                    "description": "Type: BOOL Indicates whether to write the resource updates to the file. If this parameter is TRUE, no changes are made. If it is FALSE, the changes are made: the resource updates will take effect.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EndUpdateResourceW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-endupdateresourcew",
            "description": "",
            "parameters": [
                {
                    "name": "hUpdate",
                    "type": "HANDLE",
                    "description": "Type: HANDLE A module handle returned by the BeginUpdateResource function, and used by UpdateResource, referencing the file to be updated.",
                    "possible_constants": []
                },
                {
                    "name": "fDiscard",
                    "type": "BOOL",
                    "description": "Type: BOOL Indicates whether to write the resource updates to the file. If this parameter is TRUE, no changes are made. If it is FALSE, the changes are made: the resource updates will take effect.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnterUmsSchedulingMode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enterumsschedulingmode",
            "description": "",
            "parameters": [
                {
                    "name": "SchedulerStartupInfo",
                    "type": "PUMS_SCHEDULER_STARTUP_INFO",
                    "description": "A pointer to a UMS_SCHEDULER_STARTUP_INFO structure that specifies UMS attributes for the thread, including a completion list and a UmsSchedulerProc     entry point function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnumResourceLanguagesA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enumresourcelanguagesa",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE The handle to a module to be searched. Starting with Windows\u00a0Vista, if this is a language-neutral Portable Executable (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources. If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see Resource Types. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpEnumFunc",
                    "type": "ENUMRESLANGPROCA",
                    "description": "Type: ENUMRESLANGPROC A pointer to the callback function to be called for each enumerated resource language. For more information, see EnumResLangProcA.",
                    "possible_constants": []
                },
                {
                    "name": "lParam",
                    "type": "LONG_PTR",
                    "description": "Type: LONG_PTR An application-defined value passed to the callback function. This parameter can be used in error checking.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnumResourceLanguagesW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enumresourcelanguagesw",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE The handle to a module to be searched. Starting with Windows\u00a0Vista, if this is a language-neutral Portable Executable (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources. If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see Resource Types. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpEnumFunc",
                    "type": "ENUMRESLANGPROCW",
                    "description": "Type: ENUMRESLANGPROC A pointer to the callback function to be called for each enumerated resource language. For more information, see EnumResLangProcW.",
                    "possible_constants": []
                },
                {
                    "name": "lParam",
                    "type": "LONG_PTR",
                    "description": "Type: LONG_PTR An application-defined value passed to the callback function. This parameter can be used in error checking.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnumResourceTypesA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enumresourcetypesa",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE A handle to a module to be searched. This handle must be obtained through LoadLibrary or LoadLibraryEx. See Remarks for more information. If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpEnumFunc",
                    "type": "ENUMRESTYPEPROCA",
                    "description": "Type: ENUMRESTYPEPROC A pointer to the callback function to be called for each enumerated resource type. For more information, see the EnumResTypeProc function.",
                    "possible_constants": []
                },
                {
                    "name": "lParam",
                    "type": "LONG_PTR",
                    "description": "Type: LONG_PTR An application-defined value passed to the callback function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EnumResourceTypesW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-enumresourcetypesw",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE A handle to a module to be searched. This handle must be obtained through LoadLibrary or LoadLibraryEx. See Remarks for more information. If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpEnumFunc",
                    "type": "ENUMRESTYPEPROCW",
                    "description": "Type: ENUMRESTYPEPROC A pointer to the callback function to be called for each enumerated resource type. For more information, see the EnumResTypeProc function.",
                    "possible_constants": []
                },
                {
                    "name": "lParam",
                    "type": "LONG_PTR",
                    "description": "Type: LONG_PTR An application-defined value passed to the callback function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EraseTape",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-erasetape",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device where the tape is to be erased. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwEraseType",
                    "type": "DWORD",
                    "description": "Erasing technique. This parameter can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "bImmediate",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the function returns immediately; if it is FALSE, the function does not return until the erase operation has been completed.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "EscapeCommFunction",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-escapecommfunction",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwFunc",
                    "type": "DWORD",
                    "description": "The extended function to be performed. This parameter can be one of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ExecuteUmsThread",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-executeumsthread",
            "description": "",
            "parameters": [
                {
                    "name": "UmsThread",
                    "type": "PUMS_CONTEXT",
                    "description": "A pointer to the UMS thread context of the worker thread to run.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FatalExit",
            "return_type": "__analysis_noreturn VOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-fatalexit",
            "description": "",
            "parameters": [
                {
                    "name": "ExitCode",
                    "type": "int",
                    "description": "The error code associated with the exit.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FileEncryptionStatusA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-fileencryptionstatusa",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file. [out] lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the\nfollowing values.",
                    "possible_constants": []
                },
                {
                    "name": "lpStatus",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FileEncryptionStatusW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-fileencryptionstatusw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file. [out] lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the\nfollowing values.",
                    "possible_constants": []
                },
                {
                    "name": "lpStatus",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FileTimeToDosDateTime",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-filetimetodosdatetime",
            "description": "",
            "parameters": [
                {
                    "name": "*lpFileTime",
                    "type": "const FILETIME",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpFatDate",
                    "type": "LPWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpFatTime",
                    "type": "LPWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindActCtxSectionGuid",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findactctxsectionguid",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Flags that determine how this function is to operate. Only the following flag is currently defined. [in] lpExtensionGuid Reserved; must be null.",
                    "possible_constants": []
                },
                {
                    "name": "*lpExtensionGuid",
                    "type": "const GUID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ulSectionId",
                    "type": "ULONG",
                    "description": "Identifier of the section of the activation context in which to search for the specified GUID. The following are valid GUID section identifiers: [in] lpGuidToFind Pointer to a GUID to be used as the search criteria. [out] ReturnedData Pointer to an\nACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested GUID information.",
                    "possible_constants": []
                },
                {
                    "name": "*lpGuidToFind",
                    "type": "const GUID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReturnedData",
                    "type": "PACTCTX_SECTION_KEYED_DATA",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindActCtxSectionStringA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findactctxsectionstringa",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Flags that determine how this function is to operate. Only the following flag is currently defined. [in] lpExtensionGuid Reserved; must be null.",
                    "possible_constants": []
                },
                {
                    "name": "*lpExtensionGuid",
                    "type": "const GUID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ulSectionId",
                    "type": "ULONG",
                    "description": "Identifier of the string section of the activation context in which to search for the specific string. The following are valid string section identifiers:",
                    "possible_constants": []
                },
                {
                    "name": "lpStringToFind",
                    "type": "LPCSTR",
                    "description": "Pointer to a null-terminated string to be used as the search criteria. [out] ReturnedData Pointer to an\nACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested string information.",
                    "possible_constants": []
                },
                {
                    "name": "ReturnedData",
                    "type": "PACTCTX_SECTION_KEYED_DATA",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindActCtxSectionStringW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findactctxsectionstringw",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Flags that determine how this function is to operate. Only the following flag is currently defined. [in] lpExtensionGuid Reserved; must be null.",
                    "possible_constants": []
                },
                {
                    "name": "*lpExtensionGuid",
                    "type": "const GUID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ulSectionId",
                    "type": "ULONG",
                    "description": "Identifier of the string section of the activation context in which to search for the specific string. The following are valid string section identifiers:",
                    "possible_constants": []
                },
                {
                    "name": "lpStringToFind",
                    "type": "LPCWSTR",
                    "description": "Pointer to a null-terminated string to be used as the search criteria. [out] ReturnedData Pointer to an\nACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested string information.",
                    "possible_constants": []
                },
                {
                    "name": "ReturnedData",
                    "type": "PACTCTX_SECTION_KEYED_DATA",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindAtomA",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findatoma",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The character string for which to search. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindAtomW",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findatomw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The character string for which to search. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstFileNameTransactedW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstfilenametransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE (6805).",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Reserved; specify zero (0).",
                    "possible_constants": []
                },
                {
                    "name": "StringLength",
                    "type": "LPDWORD",
                    "description": "The size of the buffer pointed to by the LinkName parameter, in characters. If this\ncall fails and the error is ERROR_MORE_DATA (234), the value that is returned by this\nparameter is the size that the buffer pointed to by LinkName must be to contain all\nthe data.",
                    "possible_constants": []
                },
                {
                    "name": "LinkName",
                    "type": "PWSTR",
                    "description": "A pointer to a buffer to store the first link name found for lpFileName.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstFileTransactedA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstfiletransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk\n(*) or a question mark (?). This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and\nall subdirectories on the path. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "fInfoLevelId",
                    "type": "FINDEX_INFO_LEVELS",
                    "description": "The information level of the returned data. This parameter is one of the\nFINDEX_INFO_LEVELS enumeration values. [out] lpFindFileData A pointer to the WIN32_FIND_DATA structure that\nreceives information about a found file or subdirectory.",
                    "possible_constants": []
                },
                {
                    "name": "lpFindFileData",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "fSearchOp",
                    "type": "FINDEX_SEARCH_OPS",
                    "description": "The type of filtering to perform that is different from wildcard matching. This parameter is one of the FINDEX_SEARCH_OPS\nenumeration values.",
                    "possible_constants": []
                },
                {
                    "name": "lpSearchFilter",
                    "type": "LPVOID",
                    "description": " A pointer to the search criteria if the specified fSearchOp needs structured search\ninformation. At this time, none of the supported fSearchOp values require extended search\ninformation. Therefore, this pointer must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwAdditionalFlags",
                    "type": "DWORD",
                    "description": "Specifies additional flags that control the search.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstFileTransactedW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstfiletransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk\n(*) or a question mark (?). This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\). If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and\nall subdirectories on the path. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "fInfoLevelId",
                    "type": "FINDEX_INFO_LEVELS",
                    "description": "The information level of the returned data. This parameter is one of the\nFINDEX_INFO_LEVELS enumeration values. [out] lpFindFileData A pointer to the WIN32_FIND_DATA structure that\nreceives information about a found file or subdirectory.",
                    "possible_constants": []
                },
                {
                    "name": "lpFindFileData",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "fSearchOp",
                    "type": "FINDEX_SEARCH_OPS",
                    "description": "The type of filtering to perform that is different from wildcard matching. This parameter is one of the FINDEX_SEARCH_OPS\nenumeration values.",
                    "possible_constants": []
                },
                {
                    "name": "lpSearchFilter",
                    "type": "LPVOID",
                    "description": " A pointer to the search criteria if the specified fSearchOp needs structured search\ninformation. At this time, none of the supported fSearchOp values require extended search\ninformation. Therefore, this pointer must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwAdditionalFlags",
                    "type": "DWORD",
                    "description": "Specifies additional flags that control the search.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstStreamTransactedW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirststreamtransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The fully qualified file name. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE (6805).",
                    "possible_constants": []
                },
                {
                    "name": "InfoLevel",
                    "type": "STREAM_INFO_LEVELS",
                    "description": "The information level of the returned data. This parameter is one of the values in the\nSTREAM_INFO_LEVELS enumeration type. [out] lpFindStreamData A pointer to a buffer that receives the file data. The format of this data depends on the value of\nthe InfoLevel parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpFindStreamData",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": " Reserved for future use. This parameter must be zero.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstVolumeA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstvolumea",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer to receive the volume GUID path, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstVolumeMountPointA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszRootPathName",
                    "type": "LPCSTR",
                    "description": "A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required. [out] lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer that receives the path to the mounted folder, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindFirstVolumeMountPointW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszRootPathName",
                    "type": "LPCWSTR",
                    "description": "A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required. [out] lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer that receives the path to the mounted folder, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindNextVolumeA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findnextvolumea",
            "description": "",
            "parameters": [
                {
                    "name": "hFindVolume",
                    "type": "HANDLE",
                    "description": "The volume search handle returned by a previous call to the\nFindFirstVolume function. [out] lpszVolumeName A pointer to a string that receives the volume GUID path that is found.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer that receives the volume GUID path, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindNextVolumeMountPointA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa",
            "description": "",
            "parameters": [
                {
                    "name": "hFindVolumeMountPoint",
                    "type": "HANDLE",
                    "description": "A mounted folder search handle returned by a previous call to the\nFindFirstVolumeMountPoint function. [out] lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer that receives the mounted folder name, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindNextVolumeMountPointW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointw",
            "description": "",
            "parameters": [
                {
                    "name": "hFindVolumeMountPoint",
                    "type": "HANDLE",
                    "description": "A mounted folder search handle returned by a previous call to the\nFindFirstVolumeMountPoint function. [out] lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer that receives the mounted folder name, in\nTCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindResourceA",
            "return_type": "HRSRC",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is NULL, the function searches the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The name of the resource. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The resource type. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the given resource type. For standard resource types, see Resource Types. For more information, see the Remarks section below.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindResourceExA",
            "return_type": "HRSRC",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourceexa",
            "description": "",
            "parameters": [
                {
                    "name": "hModule",
                    "type": "HMODULE",
                    "description": "Type: HMODULE A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is NULL, the function searches the module used to create the current process.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The resource type. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the given resource type. For standard resource types, see Resource Types. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The name of the resource. Alternately, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.",
                    "possible_constants": []
                },
                {
                    "name": "wLanguage",
                    "type": "WORD",
                    "description": "Type: WORD The language of the resource. If this parameter is MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), the current language associated with the calling thread is used. To specify a language other than the current language, use the MAKELANGID macro to create this parameter. For more information, see MAKELANGID.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FindVolumeMountPointClose",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findvolumemountpointclose",
            "description": "",
            "parameters": [
                {
                    "name": "hFindVolumeMountPoint",
                    "type": "HANDLE",
                    "description": "The mounted folder search handle to be closed. This handle must have been previously opened by the\nFindFirstVolumeMountPoint function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FormatMessage",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The formatting options, and how to interpret the lpSource parameter. The\nlow-order byte of dwFlags specifies how the function handles line breaks in the output\nbuffer. The low-order byte can also specify the maximum width of a formatted output line. This parameter can be one or more of the following values. The low-order byte of dwFlags can specify the maximum width of a formatted output\nline. The following are possible values of the low-order byte. If the low-order byte is a nonzero value other than\nFORMAT_MESSAGE_MAX_WIDTH_MASK, it specifies the maximum number of characters in an\noutput line. The function ignores regular line breaks in the message definition text. The function never splits\na string delimited by white space across a line break. The function stores hard-coded line breaks in the message\ndefinition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.",
                    "possible_constants": []
                },
                {
                    "name": "lpSource",
                    "type": "LPCVOID",
                    "description": "The location of the message definition. The type of this parameter depends upon the settings in the\ndwFlags parameter. If neither of these flags is set in dwFlags, then\nlpSource is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "dwMessageId",
                    "type": "DWORD",
                    "description": "The message identifier for the requested message. This parameter is ignored if\ndwFlags includes FORMAT_MESSAGE_FROM_STRING.",
                    "possible_constants": []
                },
                {
                    "name": "dwLanguageId",
                    "type": "DWORD",
                    "description": "The language identifier for the requested\nmessage. This parameter is ignored if dwFlags includes\nFORMAT_MESSAGE_FROM_STRING. If you pass a specific LANGID in this parameter,\nFormatMessage will return a message for that\nLANGID only. If the function cannot find a message for that\nLANGID, it sets Last-Error to\nERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,\nFormatMessage looks for a message for\nLANGIDs in the following order: [out] lpBuffer A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If\ndwFlags includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the\nfunction allocates a buffer using the LocalAlloc\nfunction, and places the pointer to the buffer at the address specified in\nlpBuffer. This buffer cannot be larger than 64K bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies\nthe size of the output buffer, in TCHARs. If\nFORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of\nTCHARs to allocate for an output buffer. The output buffer cannot be larger than 64K bytes. [in, optional] Arguments An array of values that are used as insert values in the formatted message. A %1 in the format string\nindicates the first value in the Arguments array; a %2 indicates the second argument;\nand so on. The interpretation of each value depends on the formatting information associated with the insert in the\nmessage definition. The default is to treat each value as a pointer to a null-terminated string. By default, the Arguments parameter is of type\nva_list*, which is a language- and implementation-specific data type for\ndescribing a variable number of arguments. The state of the va_list argument is\nundefined upon return from the function. To use the va_list again, destroy the\nvariable argument list pointer using va_end and reinitialize it with\nva_start. If you do not have a pointer of type\nva_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY\nflag and pass a pointer to an array of DWORD_PTR values; those values are input to\nthe message formatted as the insert values. Each insert must have a corresponding element in the array.",
                    "possible_constants": []
                },
                {
                    "name": "*Arguments",
                    "type": "va_list",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FormatMessageA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagea",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The formatting options, and how to interpret the lpSource parameter. The\nlow-order byte of dwFlags specifies how the function handles line breaks in the output\nbuffer. The low-order byte can also specify the maximum width of a formatted output line. This parameter can be one or more of the following values. The low-order byte of dwFlags can specify the maximum width of a formatted output\nline. The following are possible values of the low-order byte. If the low-order byte is a nonzero value other than\nFORMAT_MESSAGE_MAX_WIDTH_MASK, it specifies the maximum number of characters in an\noutput line. The function ignores regular line breaks in the message definition text. The function never splits\na string delimited by white space across a line break. The function stores hard-coded line breaks in the message\ndefinition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.",
                    "possible_constants": []
                },
                {
                    "name": "lpSource",
                    "type": "LPCVOID",
                    "description": "The location of the message definition. The type of this parameter depends upon the settings in the\ndwFlags parameter. If neither of these flags is set in dwFlags, then\nlpSource is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "dwMessageId",
                    "type": "DWORD",
                    "description": "The message identifier for the requested message. This parameter is ignored if\ndwFlags includes FORMAT_MESSAGE_FROM_STRING.",
                    "possible_constants": []
                },
                {
                    "name": "dwLanguageId",
                    "type": "DWORD",
                    "description": "The language identifier for the requested\nmessage. This parameter is ignored if dwFlags includes\nFORMAT_MESSAGE_FROM_STRING. If you pass a specific LANGID in this parameter,\nFormatMessage will return a message for that\nLANGID only. If the function cannot find a message for that\nLANGID, it sets Last-Error to\nERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,\nFormatMessage looks for a message for\nLANGIDs in the following order: [out] lpBuffer A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If\ndwFlags includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the\nfunction allocates a buffer using the LocalAlloc\nfunction, and places the pointer to the buffer at the address specified in\nlpBuffer. This buffer cannot be larger than 64K bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies\nthe size of the output buffer, in TCHARs. If\nFORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of\nTCHARs to allocate for an output buffer. The output buffer cannot be larger than 64K bytes. [in, optional] Arguments An array of values that are used as insert values in the formatted message. A %1 in the format string\nindicates the first value in the Arguments array; a %2 indicates the second argument;\nand so on. The interpretation of each value depends on the formatting information associated with the insert in the\nmessage definition. The default is to treat each value as a pointer to a null-terminated string. By default, the Arguments parameter is of type\nva_list*, which is a language- and implementation-specific data type for\ndescribing a variable number of arguments. The state of the va_list argument is\nundefined upon return from the function. To use the va_list again, destroy the\nvariable argument list pointer using va_end and reinitialize it with\nva_start. If you do not have a pointer of type\nva_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY\nflag and pass a pointer to an array of DWORD_PTR values; those values are input to\nthe message formatted as the insert values. Each insert must have a corresponding element in the array.",
                    "possible_constants": []
                },
                {
                    "name": "*Arguments",
                    "type": "va_list",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "FormatMessageW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagew",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The formatting options, and how to interpret the lpSource parameter. The\nlow-order byte of dwFlags specifies how the function handles line breaks in the output\nbuffer. The low-order byte can also specify the maximum width of a formatted output line. This parameter can be one or more of the following values. The low-order byte of dwFlags can specify the maximum width of a formatted output\nline. The following are possible values of the low-order byte. If the low-order byte is a nonzero value other than\nFORMAT_MESSAGE_MAX_WIDTH_MASK, it specifies the maximum number of characters in an\noutput line. The function ignores regular line breaks in the message definition text. The function never splits\na string delimited by white space across a line break. The function stores hard-coded line breaks in the message\ndefinition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.",
                    "possible_constants": []
                },
                {
                    "name": "lpSource",
                    "type": "LPCVOID",
                    "description": "The location of the message definition. The type of this parameter depends upon the settings in the\ndwFlags parameter. If neither of these flags is set in dwFlags, then\nlpSource is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "dwMessageId",
                    "type": "DWORD",
                    "description": "The message identifier for the requested message. This parameter is ignored if\ndwFlags includes FORMAT_MESSAGE_FROM_STRING.",
                    "possible_constants": []
                },
                {
                    "name": "dwLanguageId",
                    "type": "DWORD",
                    "description": "The language identifier for the requested\nmessage. This parameter is ignored if dwFlags includes\nFORMAT_MESSAGE_FROM_STRING. If you pass a specific LANGID in this parameter,\nFormatMessage will return a message for that\nLANGID only. If the function cannot find a message for that\nLANGID, it sets Last-Error to\nERROR_RESOURCE_LANG_NOT_FOUND. If you pass in zero,\nFormatMessage looks for a message for\nLANGIDs in the following order: [out] lpBuffer A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If\ndwFlags includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the\nfunction allocates a buffer using the LocalAlloc\nfunction, and places the pointer to the buffer at the address specified in\nlpBuffer. This buffer cannot be larger than 64K bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies\nthe size of the output buffer, in TCHARs. If\nFORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of\nTCHARs to allocate for an output buffer. The output buffer cannot be larger than 64K bytes. [in, optional] Arguments An array of values that are used as insert values in the formatted message. A %1 in the format string\nindicates the first value in the Arguments array; a %2 indicates the second argument;\nand so on. The interpretation of each value depends on the formatting information associated with the insert in the\nmessage definition. The default is to treat each value as a pointer to a null-terminated string. By default, the Arguments parameter is of type\nva_list*, which is a language- and implementation-specific data type for\ndescribing a variable number of arguments. The state of the va_list argument is\nundefined upon return from the function. To use the va_list again, destroy the\nvariable argument list pointer using va_end and reinitialize it with\nva_start. If you do not have a pointer of type\nva_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY\nflag and pass a pointer to an array of DWORD_PTR values; those values are input to\nthe message formatted as the insert values. Each insert must have a corresponding element in the array.",
                    "possible_constants": []
                },
                {
                    "name": "*Arguments",
                    "type": "va_list",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetActiveProcessorCount",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getactiveprocessorcount",
            "description": "",
            "parameters": [
                {
                    "name": "GroupNumber",
                    "type": "WORD",
                    "description": "The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active processors in the system.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetActiveProcessorGroupCount",
            "return_type": "WORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getactiveprocessorgroupcount",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetApplicationRecoveryCallback",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getapplicationrecoverycallback",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. This handle must have the PROCESS_VM_READ access right. [out] pRecoveryCallback A pointer to the recovery callback function. For more information, see ApplicationRecoveryCallback. [out] ppvParameter A pointer to the callback parameter. [out] pdwPingInterval The recovery ping interval, in 100-nanosecond intervals. [out] pdwFlags Reserved for future use.",
                    "possible_constants": []
                },
                {
                    "name": "*pRecoveryCallback",
                    "type": "APPLICATION_RECOVERY_CALLBACK",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*ppvParameter",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pdwPingInterval",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pdwFlags",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetApplicationRestartSettings",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getapplicationrestartsettings",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. This handle must have the PROCESS_VM_READ access right. [out, optional] pwzCommandline A pointer to a buffer that receives the restart command line specified by the application when it called the RegisterApplicationRestart function. The maximum size of the command line, in characters, is RESTART_MAX_CMD_LINE. Can be NULL if pcchSize is zero.",
                    "possible_constants": []
                },
                {
                    "name": "pwzCommandline",
                    "type": "PWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pcchSize",
                    "type": "PDWORD",
                    "description": "On input, specifies the size of the pwzCommandLine buffer, in characters. If the buffer is not large enough to receive the command line, the function fails with HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) and sets this parameter to the required buffer size, in characters. On output, specifies the size of the buffer that was used. To determine the required buffer size, set pwzCommandLine to NULL and this parameter to zero. The size includes one for the null-terminator character. Note that the function returns S_OK, not HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) in this case. [out, optional] pdwFlags A pointer to a variable that receives the flags specified by the application when it called the RegisterApplicationRestart function.",
                    "possible_constants": []
                },
                {
                    "name": "pdwFlags",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetAtomNameA",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getatomnamea",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The local atom that identifies the character string to be retrieved. [out] lpBuffer Type: LPTSTR The character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "int",
                    "description": "Type: int The size, in\ncharacters, of the buffer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetAtomNameW",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getatomnamew",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The local atom that identifies the character string to be retrieved. [out] lpBuffer Type: LPTSTR The character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "int",
                    "description": "Type: int The size, in\ncharacters, of the buffer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetBinaryTypeA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getbinarytypea",
            "description": "",
            "parameters": [
                {
                    "name": "lpApplicationName",
                    "type": "LPCSTR",
                    "description": "The full path of the file whose executable type is to be determined. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. [out] lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by\nlpApplicationName. The following constants are defined.",
                    "possible_constants": []
                },
                {
                    "name": "lpBinaryType",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetBinaryTypeW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getbinarytypew",
            "description": "",
            "parameters": [
                {
                    "name": "lpApplicationName",
                    "type": "LPCWSTR",
                    "description": "The full path of the file whose executable type is to be determined. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. [out] lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by\nlpApplicationName. The following constants are defined.",
                    "possible_constants": []
                },
                {
                    "name": "lpBinaryType",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommConfig",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommconfig",
            "description": "",
            "parameters": [
                {
                    "name": "hCommDev",
                    "type": "HANDLE",
                    "description": "A handle to the open communications device. The\nCreateFile function returns this handle. [out] lpCC A pointer to a buffer that receives a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "LPDWORD",
                    "description": "The size, in bytes, of the buffer pointed to by lpCC. When the function returns, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommmask",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out] lpEvtMask A pointer to the variable that receives a mask of events that are currently enabled. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpEvtMask",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommModemStatus",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommmodemstatus",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out] lpModemStat A pointer to a variable that receives the current state of the modem control-register values. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpModemStat",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommPorts",
            "return_type": "ULONG",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommports",
            "description": "",
            "parameters": [
                {
                    "name": "lpPortNumbers",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "uPortNumbersCount",
                    "type": "ULONG",
                    "description": "The length of the array in the lpPortNumbers parameter. [out] puPortNumbersFound The number of port numbers written to the lpPortNumbers or the length of the array required for the port numbers.",
                    "possible_constants": []
                },
                {
                    "name": "puPortNumbersFound",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommProperties",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommproperties",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out] lpCommProp A pointer to a\nCOMMPROP structure in which the communications properties information is returned. This information can be used in subsequent calls to the\nSetCommState,\nSetCommTimeouts, or\nSetupComm function to configure the communications device.",
                    "possible_constants": []
                },
                {
                    "name": "lpCommProp",
                    "type": "LPCOMMPROP",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommState",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommstate",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "A pointer to a\nDCB structure that receives the control settings information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCommTimeouts",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcommtimeouts",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out] lpCommTimeouts A pointer to a\nCOMMTIMEOUTS structure in which the time-out information is returned.",
                    "possible_constants": []
                },
                {
                    "name": "lpCommTimeouts",
                    "type": "LPCOMMTIMEOUTS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCompressedFileSizeTransactedA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcompressedfilesizetransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. [out, optional] lpFileSizeHigh A pointer to a variable that receives the high-order DWORD of the compressed file size. The function's return value is the low-order DWORD of the compressed file size. This parameter can be NULL if the high-order DWORD of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order DWORD.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileSizeHigh",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCompressedFileSizeTransactedW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcompressedfilesizetransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file. Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning. The file must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. [out, optional] lpFileSizeHigh A pointer to a variable that receives the high-order DWORD of the compressed file size. The function's return value is the low-order DWORD of the compressed file size. This parameter can be NULL if the high-order DWORD of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order DWORD.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileSizeHigh",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetComputerNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "LPDWORD",
                    "description": "On input, specifies the size of the buffer, in TCHARs. On output, the number of TCHARs copied to the destination buffer, not including the terminating null character. If the buffer is too small, the function fails and GetLastError returns ERROR_BUFFER_OVERFLOW. The lpnSize parameter specifies the size of the buffer required, including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetComputerNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew",
            "description": "",
            "parameters": [
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "LPDWORD",
                    "description": "On input, specifies the size of the buffer, in TCHARs. On output, the number of TCHARs copied to the destination buffer, not including the terminating null character. If the buffer is too small, the function fails and GetLastError returns ERROR_BUFFER_OVERFLOW. The lpnSize parameter specifies the size of the buffer required, including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCurrentActCtx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentactctx",
            "description": "",
            "parameters": [
                {
                    "name": "*lphActCtx",
                    "type": "HANDLE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCurrentDirectory",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory",
            "description": "",
            "parameters": [
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The length of the buffer for the current directory string, in TCHARs. The\nbuffer length must include room for a terminating null character. [out] lpBuffer A pointer to the buffer that receives the current directory string. This null-terminated string specifies the\nabsolute path to the current directory. To determine the required buffer size, set this parameter to NULL and the\nnBufferLength parameter to 0.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCurrentHwProfileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrenthwprofilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpHwProfileInfo",
                    "type": "LPHW_PROFILE_INFOA",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCurrentHwProfileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrenthwprofilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpHwProfileInfo",
                    "type": "LPHW_PROFILE_INFOW",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetCurrentUmsThread",
            "return_type": "PUMS_CONTEXT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentumsthread",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetDefaultCommConfigA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getdefaultcommconfiga",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCSTR",
                    "description": "The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports. [out] lpCC A pointer to a buffer that receives a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size of the buffer pointed to by lpCC, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetDefaultCommConfigW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getdefaultcommconfigw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCWSTR",
                    "description": "The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports. [out] lpCC A pointer to a buffer that receives a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size of the buffer pointed to by lpCC, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetDevicePowerState",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getdevicepowerstate",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "A handle to an object on the device, such as a file or socket, or a handle to the device itself. [out] pfOn A pointer to the variable that receives the\npower state. This value is TRUE if the device is in the working state. Otherwise, it is FALSE.",
                    "possible_constants": []
                },
                {
                    "name": "*pfOn",
                    "type": "BOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetDllDirectoryA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getdlldirectorya",
            "description": "",
            "parameters": [
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the output buffer, in characters. [out] lpBuffer A pointer to a buffer that receives the application-specific portion of the search path.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetDllDirectoryW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getdlldirectoryw",
            "description": "",
            "parameters": [
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the output buffer, in characters. [out] lpBuffer A pointer to a buffer that receives the application-specific portion of the search path.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetEnabledXStateFeatures",
            "return_type": "DWORD64",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenabledxstatefeatures",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetEnvironmentVariable",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCTSTR",
                    "description": "The name of the environment variable. [out, optional] lpBuffer A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpBuffer parameter, including the null-terminating character, in characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetEventLogInformation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-geteventloginformation",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log. The\nOpenEventLog or\nRegisterEventSource function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwInfoLevel",
                    "type": "DWORD",
                    "description": "The level of event log information to return. This parameter can be the following value. [out] lpBuffer An application-allocated buffer that receives the event log information. The format of this data depends on the value of the dwInfoLevel parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cbBufSize",
                    "type": "DWORD",
                    "description": "The size of the lpBuffer buffer, in bytes. [out] pcbBytesNeeded The function sets this parameter to the required buffer size for the requested information, regardless of whether the function succeeds. Use this value if the function fails with ERROR_INSUFFICIENT_BUFFER to allocate a buffer of the correct size.",
                    "possible_constants": []
                },
                {
                    "name": "pcbBytesNeeded",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileAttributesTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfileattributestransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file or directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "fInfoLevelId",
                    "type": "GET_FILEEX_INFO_LEVELS",
                    "description": "The level of attribute information to retrieve. This parameter can be the following value from the\nGET_FILEEX_INFO_LEVELS enumeration. [out] lpFileInformation A pointer to a buffer that receives the attribute information. The type of attribute information that is stored into this buffer is determined by the value of\nfInfoLevelId. If the fInfoLevelId parameter is\nGetFileExInfoStandard then this parameter points to a\nWIN32_FILE_ATTRIBUTE_DATA\nstructure",
                    "possible_constants": []
                },
                {
                    "name": "lpFileInformation",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileAttributesTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfileattributestransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file or directory. The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "fInfoLevelId",
                    "type": "GET_FILEEX_INFO_LEVELS",
                    "description": "The level of attribute information to retrieve. This parameter can be the following value from the\nGET_FILEEX_INFO_LEVELS enumeration. [out] lpFileInformation A pointer to a buffer that receives the attribute information. The type of attribute information that is stored into this buffer is determined by the value of\nfInfoLevelId. If the fInfoLevelId parameter is\nGetFileExInfoStandard then this parameter points to a\nWIN32_FILE_ATTRIBUTE_DATA\nstructure",
                    "possible_constants": []
                },
                {
                    "name": "lpFileInformation",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the CreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileBandwidthReservation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfilebandwidthreservation",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file. [out] lpPeriodMilliseconds A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the\ntime from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has\nbeen reserved for this handle, then the value returned is the minimum reservation period supported for this\nvolume. [out] lpBytesPerPeriod A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the\nvolume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of\nbytes per period supported for the volume. [out] pDiscardable TRUE if I/O should be completed with an error if a driver is unable to satisfy an\nI/O operation before the period expires. FALSE if the underlying subsystem does not\nsupport failing in this manner. [out] lpTransferSize The minimum size of any individual I/O request that may be issued by the application. All I/O requests\nshould be multiples of TransferSize. If no bandwidth has been reserved for this\nhandle, then the value returned is the minimum transfer size supported for this volume. [out] lpNumOutstandingRequests The number of TransferSize chunks  allowed to be outstanding with the operating\nsystem.",
                    "possible_constants": []
                },
                {
                    "name": "lpPeriodMilliseconds",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpBytesPerPeriod",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pDiscardable",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpTransferSize",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpNumOutstandingRequests",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileInformationByHandleEx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfileinformationbyhandleex",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle.",
                    "possible_constants": []
                },
                {
                    "name": "FileInformationClass",
                    "type": "FILE_INFO_BY_HANDLE_CLASS",
                    "description": "A FILE_INFO_BY_HANDLE_CLASS enumeration\nvalue that specifies the type of information to be retrieved. For a table of valid values, see the Remarks section. [out] lpFileInformation A pointer to the buffer that receives the requested file information. The structure that is returned\ncorresponds to the class that is specified by FileInformationClass. For a table of\nvalid structure types, see the Remarks section.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileInformation",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "dwBufferSize",
                    "type": "DWORD",
                    "description": "The size of the lpFileInformation buffer, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileInformationByName",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfileinformationbyname",
            "description": "",
            "parameters": [
                {
                    "name": "FileName",
                    "type": "PCWSTR",
                    "description": " The file name/path.",
                    "possible_constants": []
                },
                {
                    "name": "FileInformationClass",
                    "type": "FILE_INFO_BY_NAME_CLASS",
                    "description": " Specifies the type of information that should be retrieved.",
                    "possible_constants": []
                },
                {
                    "name": "FileInfoBuffer",
                    "type": "PVOID",
                    "description": "Size Specifies the size of the FileInfoBuffer buffer.",
                    "possible_constants": []
                },
                {
                    "name": "FileInfoBufferSize",
                    "type": "ULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFileSecurityA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfilesecuritya",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.",
                    "possible_constants": []
                },
                {
                    "name": "RequestedInformation",
                    "type": "SECURITY_INFORMATION",
                    "description": "A\nSECURITY_INFORMATION value that identifies the security information being requested. [out, optional] pSecurityDescriptor A pointer to a buffer that receives a copy of the security descriptor of the object specified by the lpFileName parameter. The calling process must have permission to view the specified aspects of the object's security status. The\nSECURITY_DESCRIPTOR structure is returned in self-relative security descriptor format.",
                    "possible_constants": []
                },
                {
                    "name": "pSecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nLength",
                    "type": "DWORD",
                    "description": "Specifies the size, in bytes, of the buffer pointed to by the pSecurityDescriptor parameter. [out] lpnLengthNeeded A pointer to the variable that receives the number of bytes necessary to store the complete security descriptor. If the returned number of bytes is less than or equal to nLength, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.",
                    "possible_constants": []
                },
                {
                    "name": "lpnLengthNeeded",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFirmwareEnvironmentVariableA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwareenvironmentvariablea",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" where 'x' represents a hexadecimal value. [out] pBuffer A pointer to a buffer that receives the value of the specified firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "pBuffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pBuffer buffer, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFirmwareEnvironmentVariableExA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwareenvironmentvariableexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": " The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCSTR",
                    "description": " The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" where 'x' represents a hexadecimal value. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "pBuffer",
                    "type": "PVOID",
                    "description": " A pointer to a buffer that receives the value of the specified firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": " The size of the pValue buffer, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "pdwAttribubutes",
                    "type": "PDWORD",
                    "description": " Bitmask identifying UEFI variable attributes associated with the variable. See SetFirmwareEnvironmentVariableEx for the bitmask definition.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFirmwareEnvironmentVariableExW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwareenvironmentvariableexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": " The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCWSTR",
                    "description": " The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" where 'x' represents a hexadecimal value. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "pBuffer",
                    "type": "PVOID",
                    "description": " A pointer to a buffer that receives the value of the specified firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": " The size of the pValue buffer, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "pdwAttribubutes",
                    "type": "PDWORD",
                    "description": " Bitmask identifying UEFI variable attributes associated with the variable. See SetFirmwareEnvironmentVariableEx for the bitmask definition.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFirmwareEnvironmentVariableW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwareenvironmentvariablew",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCWSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" where 'x' represents a hexadecimal value. [out] pBuffer A pointer to a buffer that receives the value of the specified firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "pBuffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pBuffer buffer, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFirmwareType",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfirmwaretype",
            "description": "",
            "parameters": [
                {
                    "name": "FirmwareType",
                    "type": "PFIRMWARE_TYPE",
                    "description": "A pointer to a FIRMWARE_TYPE enumeration.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFullPathNameTransactedA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfullpathnametransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file. This string can use short (the 8.3 form) or long file names. This string can be a share or volume name. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the buffer to receive the null-terminated string  for the drive and path,  in\nTCHARs. [out] lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path. [out] lpFilePart A pointer to a buffer that receives the address (in lpBuffer) of the final file\nname component in the path. Specify NULL if you do not need to receive this\ninformation. If lpBuffer points to a directory and not a file,\nlpFilePart receives 0 (zero).",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*lpFilePart",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetFullPathNameTransactedW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getfullpathnametransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file. This string can use short (the 8.3 form) or long file names. This string can be a share or volume name. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the buffer to receive the null-terminated string  for the drive and path,  in\nTCHARs. [out] lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path. [out] lpFilePart A pointer to a buffer that receives the address (in lpBuffer) of the final file\nname component in the path. Specify NULL if you do not need to receive this\ninformation. If lpBuffer points to a directory and not a file,\nlpFilePart receives 0 (zero).",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*lpFilePart",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetLogicalDriveStringsA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getlogicaldrivestringsa",
            "description": "",
            "parameters": [
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The maximum size of the buffer pointed to by lpBuffer, in\nTCHARs. This size does not include the terminating null character. If this\nparameter is zero, lpBuffer is not used. [out] lpBuffer A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the\nsystem, plus with an additional null character. Each string is a device name.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetLongPathNameTransactedA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getlongpathnametransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpszShortPath",
                    "type": "LPCSTR",
                    "description": "The path to be converted. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The path must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. [out] lpszLongPath A pointer to the buffer to receive the long path. You can use the same buffer you used for the lpszShortPath parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpszLongPath",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBuffer",
                    "type": "DWORD",
                    "description": "The size of the buffer lpszLongPath points to, in\nTCHARs.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetLongPathNameTransactedW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getlongpathnametransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszShortPath",
                    "type": "LPCWSTR",
                    "description": "The path to be converted. The path must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. [out] lpszLongPath A pointer to the buffer to receive the long path. You can use the same buffer you used for the lpszShortPath parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpszLongPath",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBuffer",
                    "type": "DWORD",
                    "description": "The size of the buffer lpszLongPath points to, in\nTCHARs.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetMailslotInfo",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getmailslotinfo",
            "description": "",
            "parameters": [
                {
                    "name": "hMailslot",
                    "type": "HANDLE",
                    "description": "A handle to a mailslot. The\nCreateMailslot function must create this handle. [out, optional] lpMaxMessageSize The maximum message size, in bytes, allowed for this mailslot. This value can be greater than or equal to the value specified in the cbMaxMsg parameter of the\nCreateMailslot function that created the mailslot. This parameter can be NULL. [out, optional] lpNextSize The size of the next message, in bytes. The following value has special meaning. This parameter can be NULL. [out, optional] lpMessageCount The total number of messages waiting to be read, when the function returns. This parameter can be NULL. [out, optional] lpReadTimeout The amount of time, in milliseconds, a read operation can wait for a message to be written to the mailslot before a time-out occurs. This parameter is filled in when the function returns. This parameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpMaxMessageSize",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpNextSize",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpMessageCount",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpReadTimeout",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetMaximumProcessorCount",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getmaximumprocessorcount",
            "description": "",
            "parameters": [
                {
                    "name": "GroupNumber",
                    "type": "WORD",
                    "description": "The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of processors that the system can have.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetMaximumProcessorGroupCount",
            "return_type": "WORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getmaximumprocessorgroupcount",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetNamedPipeClientComputerNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipeclientcomputernamea",
            "description": "",
            "parameters": [
                {
                    "name": "Pipe",
                    "type": "HANDLE",
                    "description": "A handle to an instance of a named pipe. This handle must be created by the\nCreateNamedPipe function. [out] ClientComputerName The computer name.",
                    "possible_constants": []
                },
                {
                    "name": "ClientComputerName",
                    "type": "LPSTR",
                    "description": "The size of the ClientComputerName buffer, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "ClientComputerNameLength",
                    "type": "ULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNamedPipeClientProcessId",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipeclientprocessid",
            "description": "",
            "parameters": [
                {
                    "name": "Pipe",
                    "type": "HANDLE",
                    "description": "A handle to an instance of a named pipe. This handle must be created by the\nCreateNamedPipe function. [out] ClientProcessId The process identifier.",
                    "possible_constants": []
                },
                {
                    "name": "ClientProcessId",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNamedPipeClientSessionId",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipeclientsessionid",
            "description": "",
            "parameters": [
                {
                    "name": "Pipe",
                    "type": "HANDLE",
                    "description": "A handle to an instance of a named pipe. This handle must be created by the\nCreateNamedPipe function. [out] ClientSessionId The session identifier.",
                    "possible_constants": []
                },
                {
                    "name": "ClientSessionId",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNamedPipeHandleStateA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipehandlestatea",
            "description": "",
            "parameters": [
                {
                    "name": "hNamedPipe",
                    "type": "HANDLE",
                    "description": "A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe. This parameter can also be a handle to an anonymous pipe, as returned by the\nCreatePipe function. [out, optional] lpState A pointer to a variable that indicates the current state of the handle. This parameter can be NULL if this information is not needed. Either or both of the following values can be specified. [out, optional] lpCurInstances A pointer to a variable that receives the number of current pipe instances. This parameter can be NULL if this information is not required. [out, optional] lpMaxCollectionCount A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be NULL if this information is not required. [out, optional] lpCollectDataTimeout A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be NULL if this information is not required. [out, optional] lpUserName A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access. This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter can be NULL if this information is not required.",
                    "possible_constants": []
                },
                {
                    "name": "lpState",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpCurInstances",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpMaxCollectionCount",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpCollectDataTimeout",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpUserName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nMaxUserNameSize",
                    "type": "DWORD",
                    "description": "The size of the buffer specified by the lpUserName parameter, in TCHARs. This parameter is ignored if lpUserName is NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNamedPipeServerProcessId",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipeserverprocessid",
            "description": "",
            "parameters": [
                {
                    "name": "Pipe",
                    "type": "HANDLE",
                    "description": "A handle to an instance of a named pipe. This handle must be created by the\nCreateNamedPipe function. [out] ServerProcessId The process identifier.",
                    "possible_constants": []
                },
                {
                    "name": "ServerProcessId",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNamedPipeServerSessionId",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnamedpipeserversessionid",
            "description": "",
            "parameters": [
                {
                    "name": "Pipe",
                    "type": "HANDLE",
                    "description": "A handle to an instance of a named pipe. This handle must be created by the\nCreateNamedPipe function. [out] ServerSessionId The session identifier.",
                    "possible_constants": []
                },
                {
                    "name": "ServerSessionId",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNextUmsListItem",
            "return_type": "PUMS_CONTEXT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnextumslistitem",
            "description": "",
            "parameters": [
                {
                    "name": "UmsContext",
                    "type": "PUMS_CONTEXT",
                    "description": "A pointer to a UMS context in a list of thread contexts. This list is retrieved by the DequeueUmsCompletionListItems function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaAvailableMemoryNode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumaavailablememorynode",
            "description": "",
            "parameters": [
                {
                    "name": "Node",
                    "type": "UCHAR",
                    "description": "The number of the node. [out] AvailableBytes The amount of available memory for the node, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "AvailableBytes",
                    "type": "PULONGLONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaAvailableMemoryNodeEx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumaavailablememorynodeex",
            "description": "",
            "parameters": [
                {
                    "name": "Node",
                    "type": "USHORT",
                    "description": "The number of the node. [out] AvailableBytes The amount of available memory for the node, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "AvailableBytes",
                    "type": "PULONGLONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaNodeNumberFromHandle",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumanodenumberfromhandle",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks, and sockets. For more information, see the CreateFile function. [out] NodeNumber A pointer to a variable to receive the number of the NUMA node associated with the specified file handle.",
                    "possible_constants": []
                },
                {
                    "name": "NodeNumber",
                    "type": "PUSHORT",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaNodeProcessorMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumanodeprocessormask",
            "description": "",
            "parameters": [
                {
                    "name": "Node",
                    "type": "UCHAR",
                    "description": "The number of the node. [out] ProcessorMask The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node. If the node has no processors configured, the processor mask is zero. On systems with more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same processor group as the calling thread. Otherwise, the parameter is set to zero.",
                    "possible_constants": []
                },
                {
                    "name": "ProcessorMask",
                    "type": "PULONGLONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaProcessorNode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumaprocessornode",
            "description": "",
            "parameters": [
                {
                    "name": "Processor",
                    "type": "UCHAR",
                    "description": "The processor number. On a system with more than 64 logical processors, the processor number is relative to the processor group that contains the processor on which the calling thread is running. [out] NodeNumber The node number. If the processor does not exist, this parameter is 0xFF.",
                    "possible_constants": []
                },
                {
                    "name": "NodeNumber",
                    "type": "PUCHAR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaProcessorNodeEx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumaprocessornodeex",
            "description": "",
            "parameters": [
                {
                    "name": "Processor",
                    "type": "PPROCESSOR_NUMBER",
                    "description": "A pointer to a PROCESSOR_NUMBER structure that represents the logical processor and the processor group to which it is assigned. [out] NodeNumber A pointer  to a variable to receive the node number. If the specified processor does not exist, this parameter is set to MAXUSHORT.",
                    "possible_constants": []
                },
                {
                    "name": "NodeNumber",
                    "type": "PUSHORT",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumaProximityNode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumaproximitynode",
            "description": "",
            "parameters": [
                {
                    "name": "ProximityId",
                    "type": "ULONG",
                    "description": "The proximity domain identifier of the node. [out] NodeNumber The node number. If the processor does not exist, this parameter is 0xFF.",
                    "possible_constants": []
                },
                {
                    "name": "NodeNumber",
                    "type": "PUCHAR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetNumberOfEventLogRecords",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getnumberofeventlogrecords",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the open event log. The\nOpenEventLog or\nOpenBackupEventLog function returns this handle. [out] NumberOfRecords A pointer to a variable that receives the number of records in the specified event log.",
                    "possible_constants": []
                },
                {
                    "name": "NumberOfRecords",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetOldestEventLogRecord",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getoldesteventlogrecord",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the open event log. The\nOpenEventLog or\nOpenBackupEventLog function returns this handle. [out] OldestRecord A pointer to a variable that receives the absolute record number of the oldest record in the specified event log.",
                    "possible_constants": []
                },
                {
                    "name": "OldestRecord",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileInt",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofileint",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCTSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCTSTR",
                    "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the\nGetPrivateProfileInt function converts the string into an integer and returns the integer.",
                    "possible_constants": []
                },
                {
                    "name": "nDefault",
                    "type": "INT",
                    "description": "The default value to return if the key name cannot be found in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileIntA",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofileinta",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the\nGetPrivateProfileInt function converts the string into an integer and returns the integer.",
                    "possible_constants": []
                },
                {
                    "name": "nDefault",
                    "type": "INT",
                    "description": "The default value to return if the key name cannot be found in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileIntW",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofileintw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the\nGetPrivateProfileInt function converts the string into an integer and returns the integer.",
                    "possible_constants": []
                },
                {
                    "name": "nDefault",
                    "type": "INT",
                    "description": "The default value to return if the key name cannot be found in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSection",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesection",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCTSTR",
                    "description": "The name of the section in the initialization file. [out] lpReturnedString A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters. Note: In earlier Windows versions, the maximum profile section size is 32,767 characters. Windows 7 and newer versions don't have this limitation.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSectionA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesectiona",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section in the initialization file. [out] lpReturnedString A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters. Note: In earlier Windows versions, the maximum profile section size is 32,767 characters. Windows 7 and newer versions don't have this limitation.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSectionNames",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesectionnames",
            "description": "",
            "parameters": [
                {
                    "name": "lpszReturnBuffer",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpszReturnBuffer parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the initialization file. If this parameter is NULL, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSectionNamesA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesectionnamesa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszReturnBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpszReturnBuffer parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter is NULL, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSectionNamesW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesectionnamesw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszReturnBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpszReturnBuffer parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter is NULL, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileSectionW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilesectionw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section in the initialization file. [out] lpReturnedString A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters. Note: In earlier Windows versions, the maximum profile section size is 32,767 characters. Windows 7 and newer versions don't have this limitation.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileString",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestring",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCTSTR",
                    "description": "The name of the section containing the key name. If this parameter is NULL, the\nGetPrivateProfileString function copies all section names in the file to the supplied buffer.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCTSTR",
                    "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, all key names in the section specified by the lpAppName parameter are copied to the buffer specified by the lpReturnedString parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpDefault",
                    "type": "LPCTSTR",
                    "description": "A default string. If the lpKeyName key cannot be found in the initialization file,\nGetPrivateProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks. [out] lpReturnedString A pointer to the buffer that receives the retrieved string.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCTSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileStringA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestringa",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section containing the key name. If this parameter is NULL, the\nGetPrivateProfileString function copies all section names in the file to the supplied buffer.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, all key names in the section specified by the lpAppName parameter are copied to the buffer specified by the lpReturnedString parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpDefault",
                    "type": "LPCSTR",
                    "description": "A default string. If the lpKeyName key cannot be found in the initialization file,\nGetPrivateProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks. [out] lpReturnedString A pointer to the buffer that receives the retrieved string.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileStringW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestringw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section containing the key name. If this parameter is NULL, the\nGetPrivateProfileString function copies all section names in the file to the supplied buffer.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, all key names in the section specified by the lpAppName parameter are copied to the buffer specified by the lpReturnedString parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpDefault",
                    "type": "LPCWSTR",
                    "description": "A default string. If the lpKeyName key cannot be found in the initialization file,\nGetPrivateProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks. [out] lpReturnedString A pointer to the buffer that receives the retrieved string.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileStruct",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestruct",
            "description": "",
            "parameters": [
                {
                    "name": "lpszSection",
                    "type": "LPCTSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpszKey",
                    "type": "LPCTSTR",
                    "description": "The name of the key whose data is to be retrieved. [out] lpStruct A pointer to the buffer that receives the data associated with the file, section, and key names.",
                    "possible_constants": []
                },
                {
                    "name": "lpStruct",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "uSizeStruct",
                    "type": "UINT",
                    "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "szFile",
                    "type": "LPCTSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileStructA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestructa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszSection",
                    "type": "LPCSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpszKey",
                    "type": "LPCSTR",
                    "description": "The name of the key whose data is to be retrieved. [out] lpStruct A pointer to the buffer that receives the data associated with the file, section, and key names.",
                    "possible_constants": []
                },
                {
                    "name": "lpStruct",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "uSizeStruct",
                    "type": "UINT",
                    "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "szFile",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetPrivateProfileStructW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprivateprofilestructw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszSection",
                    "type": "LPCWSTR",
                    "description": "The name of the section in the initialization file.",
                    "possible_constants": []
                },
                {
                    "name": "lpszKey",
                    "type": "LPCWSTR",
                    "description": "The name of the key whose data is to be retrieved. [out] lpStruct A pointer to the buffer that receives the data associated with the file, section, and key names.",
                    "possible_constants": []
                },
                {
                    "name": "lpStruct",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "uSizeStruct",
                    "type": "UINT",
                    "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "szFile",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProcessAffinityMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprocessaffinitymask",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process whose affinity mask is desired. This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see\nProcess Security and Access Rights. Windows Server\u00a02003 and Windows\u00a0XP:\u00a0\u00a0The handle must have the PROCESS_QUERY_INFORMATION access right. [out] lpProcessAffinityMask A pointer to a variable that receives the affinity mask for the specified process. [out] lpSystemAffinityMask A pointer to a variable that receives the affinity mask for the system.",
                    "possible_constants": []
                },
                {
                    "name": "lpProcessAffinityMask",
                    "type": "PDWORD_PTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpSystemAffinityMask",
                    "type": "PDWORD_PTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProcessDEPPolicy",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprocessdeppolicy",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. PROCESS_QUERY_INFORMATION privilege is required to get the DEP policy of a process. Windows\u00a0XP with SP3:\u00a0\u00a0The hProcess parameter is ignored. [out] lpFlags A DWORD that receives one or more of the following flags. [out] lpPermanent TRUE if DEP is enabled or disabled permanently for the specified process; otherwise FALSE. If lpPermanent is TRUE, the current DEP setting persists for the life of the process and cannot be changed by calling SetProcessDEPPolicy.",
                    "possible_constants": []
                },
                {
                    "name": "lpFlags",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpPermanent",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProcessIoCounters",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprocessiocounters",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see\nProcess Security and Access Rights. Windows Server\u00a02003 and Windows\u00a0XP:\u00a0\u00a0The handle must have the PROCESS_QUERY_INFORMATION access right. [out] lpIoCounters A pointer to an\nIO_COUNTERS structure that receives the I/O accounting information for the process.",
                    "possible_constants": []
                },
                {
                    "name": "lpIoCounters",
                    "type": "PIO_COUNTERS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileIntA",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofileinta",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section containing the key name.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the\nGetProfileInt function converts the string into an integer and returns the integer.",
                    "possible_constants": []
                },
                {
                    "name": "nDefault",
                    "type": "INT",
                    "description": "The default value to return if the key name cannot be found in the initialization file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileIntW",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofileintw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section containing the key name.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the\nGetProfileInt function converts the string into an integer and returns the integer.",
                    "possible_constants": []
                },
                {
                    "name": "nDefault",
                    "type": "INT",
                    "description": "The default value to return if the key name cannot be found in the initialization file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileSectionA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofilesectiona",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section in the Win.ini file. [out] lpReturnedString A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters. The maximum profile section size is 32,767 characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileSectionW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofilesectionw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section in the Win.ini file. [out] lpReturnedString A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters. The maximum profile section size is 32,767 characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileStringA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofilestringa",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section containing the key. If this parameter is NULL, the function copies all section names in the file to the supplied buffer.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, the function copies all keys in the given section to the supplied buffer. Each string is followed by a null character, and the final string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpDefault",
                    "type": "LPCSTR",
                    "description": "A default string. If the lpKeyName key cannot be found in the initialization file,\nGetProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks. [out] lpReturnedString A pointer to a buffer that receives the character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetProfileStringW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprofilestringw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section containing the key. If this parameter is NULL, the function copies all section names in the file to the supplied buffer.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, the function copies all keys in the given section to the supplied buffer. Each string is followed by a null character, and the final string is followed by a second null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpDefault",
                    "type": "LPCWSTR",
                    "description": "A default string. If the lpKeyName key cannot be found in the initialization file,\nGetProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks. [out] lpReturnedString A pointer to a buffer that receives the character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpReturnedString",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetShortPathNameA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getshortpathnamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpszLongPath",
                    "type": "LPCSTR",
                    "description": "The path string. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. [out] lpszShortPath A pointer to a buffer to receive the null-terminated short form of the path that\nlpszLongPath specifies. Passing NULL for this parameter and zero for cchBuffer\nwill always return the required buffer size for a specified lpszLongPath.",
                    "possible_constants": []
                },
                {
                    "name": "lpszShortPath",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBuffer",
                    "type": "DWORD",
                    "description": "The size of the buffer  that lpszShortPath points to, in\nTCHARs. Set this parameter to zero if lpszShortPath is set to NULL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetSystemDEPPolicy",
            "return_type": "DEP_SYSTEM_POLICY_TYPE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getsystemdeppolicy",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetSystemPowerStatus",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getsystempowerstatus",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemPowerStatus",
                    "type": "LPSYSTEM_POWER_STATUS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetSystemRegistryQuota",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getsystemregistryquota",
            "description": "",
            "parameters": [
                {
                    "name": "pdwQuotaAllowed",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pdwQuotaUsed",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetTapeParameters",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-gettapeparameters",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device about which information is sought. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwOperation",
                    "type": "DWORD",
                    "description": "Type of information requested. This parameter must be one of the following values. [out] lpdwSize Pointer to a variable that receives the size, in bytes, of the buffer specified by the lpTapeInformation parameter. If the buffer is too small, this parameter receives the required size. [out] lpTapeInformation Pointer to a structure that contains the requested information. If the dwOperation parameter is GET_TAPE_MEDIA_INFORMATION, lpTapeInformation points to a\nTAPE_GET_MEDIA_PARAMETERS structure. If dwOperation is GET_TAPE_DRIVE_INFORMATION, lpTapeInformation points to a\nTAPE_GET_DRIVE_PARAMETERS structure.",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpTapeInformation",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetTapePosition",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-gettapeposition",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device on which to get the tape position. This handle is created by using\nCreateFile.",
                    "possible_constants": []
                },
                {
                    "name": "dwPositionType",
                    "type": "DWORD",
                    "description": "Type of address to obtain. This parameter can be one of the following values. [out] lpdwPartition Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero. [out] lpdwOffsetLow Pointer to a variable that receives the low-order bits of the current tape position. [out] lpdwOffsetHigh Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be NULL if the high-order bits are not required.",
                    "possible_constants": []
                },
                {
                    "name": "lpdwPartition",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwOffsetLow",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwOffsetHigh",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetTapeStatus",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-gettapestatus",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device for which to get the device status. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetTempFileName",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-gettempfilename",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCTSTR",
                    "description": "The directory path for the file name. Applications typically specify a period (.) for the current directory\nor the result of the GetTempPath2 function. The string\ncannot be longer than MAX_PATH\u00e2\u0080\u009314 characters or\nGetTempFileName will fail. If this parameter is\nNULL, the function fails.",
                    "possible_constants": []
                },
                {
                    "name": "lpPrefixString",
                    "type": "LPCTSTR",
                    "description": "The null-terminated prefix string. The function uses up to the first three characters of this string as the\nprefix of the file name. This string must consist of characters in the OEM-defined character set.",
                    "possible_constants": []
                },
                {
                    "name": "uUnique",
                    "type": "UINT",
                    "description": "An unsigned integer to be used in creating the temporary file name. For more information, see Remarks. If uUnique is zero, the function attempts to form a unique file name using the\ncurrent system time. If the file already exists, the number is increased by one and the functions tests if this\nfile already exists. This continues until a unique filename is found; the function creates a file by that name\nand closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when\nuUnique is nonzero. [out] lpTempFileName A pointer to the buffer that receives the temporary file name. This buffer should be\nMAX_PATH characters to accommodate the path plus the terminating null character.",
                    "possible_constants": []
                },
                {
                    "name": "lpTempFileName",
                    "type": "LPTSTR",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetThreadEnabledXStateFeatures",
            "return_type": "DWORD64",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getthreadenabledxstatefeatures",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GetThreadSelectorEntry",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getthreadselectorentry",
            "description": "",
            "parameters": [
                {
                    "name": "hThread",
                    "type": "HANDLE",
                    "description": "A handle to the thread containing the specified selector. The handle must have THREAD_QUERY_INFORMATION access. For more information, see\nThread Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwSelector",
                    "type": "DWORD",
                    "description": "The global or local selector value to look up in the thread's descriptor tables. [out] lpSelectorEntry A pointer to an\nLDT_ENTRY structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.",
                    "possible_constants": []
                },
                {
                    "name": "lpSelectorEntry",
                    "type": "LPLDT_ENTRY",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetUmsCompletionListEvent",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getumscompletionlistevent",
            "description": "",
            "parameters": [
                {
                    "name": "UmsCompletionList",
                    "type": "PUMS_COMPLETION_LIST",
                    "description": "A pointer to a UMS completion list. The CreateUmsCompletionList function provides this pointer.",
                    "possible_constants": []
                },
                {
                    "name": "UmsCompletionEvent",
                    "type": "PHANDLE",
                    "description": "A pointer to a HANDLE variable. On output, the UmsCompletionEvent parameter is set to a handle to the event associated with the specified completion list.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetUmsSystemThreadInformation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getumssystemthreadinformation",
            "description": "",
            "parameters": [
                {
                    "name": "ThreadHandle",
                    "type": "HANDLE",
                    "description": "A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more information, see Thread Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "SystemThreadInfo",
                    "type": "PUMS_SYSTEM_THREAD_INFORMATION",
                    "description": "A pointer to a UMS_SYSTEM_THREAD_INFORMATION structure that receives information about the specified thread. The caller must initialize the UmsVersion member before calling.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetUserNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pcbBuffer",
                    "type": "LPDWORD",
                    "description": "On input, this variable specifies the size of the lpBuffer buffer, in TCHARs. On output, the variable receives the number of TCHARs copied to the buffer, including the terminating null character. If lpBuffer is too small, the function fails and GetLastError returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetUserNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamew",
            "description": "",
            "parameters": [
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pcbBuffer",
                    "type": "LPDWORD",
                    "description": "On input, this variable specifies the size of the lpBuffer buffer, in TCHARs. On output, the variable receives the number of TCHARs copied to the buffer, including the terminating null character. If lpBuffer is too small, the function fails and GetLastError returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetVolumeNameForVolumeMountPointA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getvolumenameforvolumemountpointa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPCSTR",
                    "description": "A pointer to a string that contains the path of a mounted folder (for example, \"Y:\\MountX\") or a drive letter (for example, \"X:\\\"). The string must end with a trailing backslash (''). [out] lpszVolumeName A pointer to a string that receives the volume GUID path. This path is of the form \"\\?\\Volume{GUID}\" where GUID is a GUID that identifies the volume. If there is more than one volume GUID path for the volume, only the first one in the mount manager's cache is returned.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the output buffer, in TCHARs. A reasonable size for the buffer to accommodate the largest possible volume GUID path is 50 characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetVolumePathNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getvolumepathnamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpszFileName",
                    "type": "LPCSTR",
                    "description": "A pointer to the input path string. Both absolute and relative file and directory names, for example\n\"..\", are acceptable in this path. If you specify a relative directory or file name without a volume qualifier,\nGetVolumePathName returns the drive letter of the\nboot volume. If this parameter is an empty string, \"\", the function fails but the last error is set to\nERROR_SUCCESS. [out] lpszVolumePathName A pointer to a string that receives the volume mount point for the input path.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumePathName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the output buffer, in TCHARs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetVolumePathNamesForVolumeNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getvolumepathnamesforvolumenamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeName",
                    "type": "LPCSTR",
                    "description": "A volume GUID path for the volume. A volume GUID\npath is of the form\n\"\\?\\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\". [out] lpszVolumePathNames A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an\narray of null-terminated strings terminated by an additional NULL character. If the\nbuffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumePathNames",
                    "type": "LPCH",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchBufferLength",
                    "type": "DWORD",
                    "description": "The length of the lpszVolumePathNames buffer, in\nTCHARs, including all NULL characters. [out] lpcchReturnLength If the call is successful, this parameter is the number of TCHARs copied to\nthe lpszVolumePathNames buffer. Otherwise, this parameter is the size of the buffer\nrequired to hold the complete list, in TCHARs.",
                    "possible_constants": []
                },
                {
                    "name": "lpcchReturnLength",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GetXStateFeaturesMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getxstatefeaturesmask",
            "description": "",
            "parameters": [
                {
                    "name": "Context",
                    "type": "PCONTEXT",
                    "description": "A pointer to a CONTEXT structure that has been\ninitialized with InitializeContext. [out] FeatureMask A pointer to a variable that receives the mask of XState features which are present in the specified\nCONTEXT structure.",
                    "possible_constants": []
                },
                {
                    "name": "FeatureMask",
                    "type": "PDWORD64",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalAddAtomA",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the GlobalGetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalAddAtomExA",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatomexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the GlobalGetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalAddAtomExW",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatomexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the GlobalGetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalAddAtomW",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatomw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the GlobalGetAtomName function. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalAlloc",
            "return_type": "DECLSPEC_ALLOCATOR HGLOBAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc",
            "description": "",
            "parameters": [
                {
                    "name": "uFlags",
                    "type": "UINT",
                    "description": "The memory allocation attributes. If zero is specified, the default is GMEM_FIXED. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted. The following values are obsolete, but are provided for compatibility with 16-bit Windows. They are ignored.",
                    "possible_constants": []
                },
                {
                    "name": "dwBytes",
                    "type": "SIZE_T",
                    "description": "The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies GMEM_MOVEABLE, the function returns a handle to a memory object that is marked as discarded.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalDeleteAtom",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaldeleteatom",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The atom and character string to be deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalDiscard",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaldiscard",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "GlobalFindAtomA",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfindatoma",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The null-terminated character string for which to search. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalFindAtomW",
            "return_type": "ATOM",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfindatomw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The null-terminated character string for which to search. Alternatively, you can use an integer atom that has been converted using the MAKEINTATOM macro. See the Remarks for more information.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalFlags",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalflags",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HGLOBAL",
                    "description": "A handle to the global memory object. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalFree",
            "return_type": "HGLOBAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "_Frees_ptr_opt_ HGLOBAL",
                    "description": "A handle to the global memory object. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function. It is not safe to free memory allocated with LocalAlloc.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalGetAtomNameA",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalgetatomnamea",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The global atom associated with the character string to be retrieved. [out] lpBuffer Type: LPTSTR The buffer for the character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "int",
                    "description": "Type: int The size, in\ncharacters, of the buffer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalGetAtomNameW",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalgetatomnamew",
            "description": "",
            "parameters": [
                {
                    "name": "nAtom",
                    "type": "ATOM",
                    "description": "Type: ATOM The global atom associated with the character string to be retrieved. [out] lpBuffer Type: LPTSTR The buffer for the character string.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "int",
                    "description": "Type: int The size, in\ncharacters, of the buffer.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalHandle",
            "return_type": "HGLOBAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalhandle",
            "description": "",
            "parameters": [
                {
                    "name": "pMem",
                    "type": "LPCVOID",
                    "description": "A pointer to the first byte of the global memory block. This pointer is returned by the\nGlobalLock function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalLock",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globallock",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HGLOBAL",
                    "description": "A handle to the global memory object. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalMemoryStatus",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalmemorystatus",
            "description": "",
            "parameters": [
                {
                    "name": "lpBuffer",
                    "type": "LPMEMORYSTATUS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalReAlloc",
            "return_type": "DECLSPEC_ALLOCATOR HGLOBAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalrealloc",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "_Frees_ptr_ HGLOBAL",
                    "description": "A handle to the global memory object to be reallocated. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function.",
                    "possible_constants": []
                },
                {
                    "name": "dwBytes",
                    "type": "SIZE_T",
                    "description": "The new size of the memory block, in bytes. If uFlags specifies GMEM_MODIFY, this parameter is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "uFlags",
                    "type": "UINT",
                    "description": "The reallocation options. If GMEM_MODIFY is specified, the function modifies the attributes of the memory object only (the dwBytes parameter is ignored.) Otherwise, the function reallocates the memory object. You can optionally combine GMEM_MODIFY with the following value. If this parameter does not specify GMEM_MODIFY, you can use the following value.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalSize",
            "return_type": "SIZE_T",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalsize",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HGLOBAL",
                    "description": "A handle to the global memory object. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "GlobalUnlock",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalunlock",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HGLOBAL",
                    "description": "A handle to the global memory object. This handle is returned by either the\nGlobalAlloc or\nGlobalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "HasOverlappedIoCompleted",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-hasoverlappediocompleted",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "InitAtomTable",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-initatomtable",
            "description": "",
            "parameters": [
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "Type: DWORD The number of hash buckets to use for the atom table. If this parameter is zero, the default number of hash buckets are created. To achieve better performance, specify a prime number in\nnSize.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "InitializeContext",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-initializecontext",
            "description": "",
            "parameters": [
                {
                    "name": "Buffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ContextFlags",
                    "type": "DWORD",
                    "description": "A value indicating which portions of the Context structure should be initialized.\nThis parameter influences the size of the initialized Context structure. [out, optional] Context A pointer to a variable which receives the address of the initialized\nCONTEXT structure within the\nBuffer.",
                    "possible_constants": []
                },
                {
                    "name": "*Context",
                    "type": "PCONTEXT",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ContextLength",
                    "type": "PDWORD",
                    "description": "On input, specifies the length of the buffer pointed to by Buffer, in bytes. If\nthe buffer is not large enough to contain the specified portions of the\nCONTEXT, the function fails,\nGetLastError returns\nERROR_INSUFFICIENT_BUFFER, and ContextLength is set to the\nrequired size of the buffer.  If the function fails with an error other than\nERROR_INSUFFICIENT_BUFFER, the contents of\nContextLength are undefined.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "InitializeContext2",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-initializecontext2",
            "description": "",
            "parameters": [
                {
                    "name": "Buffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ContextFlags",
                    "type": "DWORD",
                    "description": " A value indicating which portions of the Context structure should be initialized.\nThis parameter influences the size of the initialized Context structure. [out, optional] Context A pointer to a variable which receives the address of the initialized\nCONTEXT structure within the\nBuffer.",
                    "possible_constants": []
                },
                {
                    "name": "*Context",
                    "type": "PCONTEXT",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ContextLength",
                    "type": "PDWORD",
                    "description": "On input, specifies the length of the buffer pointed to by Buffer, in bytes. If\nthe buffer is not large enough to contain the specified portions of the\nCONTEXT, the function fails,\nGetLastError returns\nERROR_INSUFFICIENT_BUFFER, and ContextLength is set to the\nrequired size of the buffer.  If the function fails with an error other than\nERROR_INSUFFICIENT_BUFFER, the contents of\nContextLength are undefined.",
                    "possible_constants": []
                },
                {
                    "name": "XStateCompactionMask",
                    "type": "ULONG64",
                    "description": " Supplies the XState compaction mask to use when allocating the Context structure.\nThis parameter is only used when CONTEXT_XSTATE is supplied to ContextFlags and the system has XState enabled in compaction mode.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "InitializeThreadpoolEnvironment",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-initializethreadpoolenvironment",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "InterlockedExchangeSubtract",
            "return_type": "unsigned",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-interlockedexchangesubtract",
            "description": "",
            "parameters": [
                {
                    "name": "*Addend",
                    "type": "unsigned volatile",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "Value",
                    "type": "unsigned",
                    "description": "The value to be subtracted from the variable pointed to by the Addend parameter.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsBadCodePtr",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadcodeptr",
            "description": "",
            "parameters": [
                {
                    "name": "lpfn",
                    "type": "FARPROC",
                    "description": "A pointer to a memory address.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsBadReadPtr",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadreadptr",
            "description": "",
            "parameters": [
                {
                    "name": "*lp",
                    "type": "const VOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ucb",
                    "type": "UINT_PTR",
                    "description": "The size of the memory block, in bytes. If this parameter is zero, the return value is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsBadStringPtrA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadstringptra",
            "description": "",
            "parameters": [
                {
                    "name": "lpsz",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string, either Unicode or ASCII.",
                    "possible_constants": []
                },
                {
                    "name": "ucchMax",
                    "type": "UINT_PTR",
                    "description": "The maximum size of the string, in TCHARs. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsBadStringPtrW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadstringptrw",
            "description": "",
            "parameters": [
                {
                    "name": "lpsz",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string, either Unicode or ASCII.",
                    "possible_constants": []
                },
                {
                    "name": "ucchMax",
                    "type": "UINT_PTR",
                    "description": "The maximum size of the string, in TCHARs. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsBadWritePtr",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isbadwriteptr",
            "description": "",
            "parameters": [
                {
                    "name": "lp",
                    "type": "LPVOID",
                    "description": "A pointer to the first byte of the memory block.",
                    "possible_constants": []
                },
                {
                    "name": "ucb",
                    "type": "UINT_PTR",
                    "description": "The size of the memory block, in bytes. If this parameter is zero, the return value is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsNativeVhdBoot",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-isnativevhdboot",
            "description": "",
            "parameters": [
                {
                    "name": "NativeVhdBoot",
                    "type": "PBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "IsSystemResumeAutomatic",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-issystemresumeautomatic",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "IsTextUnicode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-istextunicode",
            "description": "",
            "parameters": [
                {
                    "name": "*lpv",
                    "type": "const VOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "iSize",
                    "type": "int",
                    "description": "Size, in bytes, of the input buffer indicated by lpv.",
                    "possible_constants": []
                },
                {
                    "name": "lpiResult",
                    "type": "LPINT",
                    "description": "On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output. If lpiResult is NULL, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text. This parameter can be one or more of the following values. Values can be combined with binary \"OR\".",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LoadModule",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-loadmodule",
            "description": "",
            "parameters": [
                {
                    "name": "lpModuleName",
                    "type": "LPCSTR",
                    "description": "The file name of the application to be run. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). If the lpModuleName parameter does not contain a directory path, the system searches for the executable file in this order:",
                    "possible_constants": []
                },
                {
                    "name": "lpParameterBlock",
                    "type": "LPVOID",
                    "description": "A pointer to an application-defined LOADPARMS32 structure that defines the new application's parameter block. Set all unused members to NULL, except for lpCmdLine, which must point to a null-terminated string if it is not used. For more information, see Remarks.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LoadPackagedLibrary",
            "return_type": "HMODULE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-loadpackagedlibrary",
            "description": "",
            "parameters": [
                {
                    "name": "lpwLibFileName",
                    "type": "LPCWSTR",
                    "description": "The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable module (an .exe file). If this parameter specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string. If this parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path or a relative path that contains \"..\" in the path.   When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces. If the specified module is already loaded in the process, the function returns a handle to the loaded module. The module must have been originally loaded  from the package dependency graph of the process. If loading the specified module causes the system to load other associated modules, the function first searches loaded modules, then it searches the package dependency graph of the process.  For more information, see Remarks.",
                    "possible_constants": []
                },
                {
                    "name": "Reserved",
                    "type": "DWORD",
                    "description": " This parameter is reserved. It must be 0.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalAlloc",
            "return_type": "DECLSPEC_ALLOCATOR HLOCAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc",
            "description": "",
            "parameters": [
                {
                    "name": "uFlags",
                    "type": "UINT",
                    "description": "The memory allocation attributes. The default is the LMEM_FIXED value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted. The following values are obsolete, but are provided for compatibility with 16-bit Windows. They are ignored.",
                    "possible_constants": []
                },
                {
                    "name": "uBytes",
                    "type": "SIZE_T",
                    "description": "The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies LMEM_MOVEABLE, the function returns a handle to a memory object that is marked as discarded.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalFlags",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localflags",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HLOCAL",
                    "description": "A handle to the local memory object. This handle is returned by either the\nLocalAlloc or\nLocalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalFree",
            "return_type": "HLOCAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "_Frees_ptr_opt_ HLOCAL",
                    "description": "A handle to the local memory object. This handle is returned by either the\nLocalAlloc or\nLocalReAlloc function. It is not safe to free memory allocated with GlobalAlloc.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalHandle",
            "return_type": "HLOCAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localhandle",
            "description": "",
            "parameters": [
                {
                    "name": "pMem",
                    "type": "LPCVOID",
                    "description": "A pointer to the first byte of the local memory object. This pointer is returned by the\nLocalLock function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalLock",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-locallock",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HLOCAL",
                    "description": "A handle to the local memory object. This handle is returned by either the\nLocalAlloc or\nLocalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalReAlloc",
            "return_type": "DECLSPEC_ALLOCATOR HLOCAL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localrealloc",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "_Frees_ptr_opt_ HLOCAL",
                    "description": "A handle to the local memory object to be reallocated. This handle is returned by either the\nLocalAlloc or\nLocalReAlloc function.",
                    "possible_constants": []
                },
                {
                    "name": "uBytes",
                    "type": "SIZE_T",
                    "description": "The new size of the memory block, in bytes. If uFlags specifies LMEM_MODIFY, this parameter is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "uFlags",
                    "type": "UINT",
                    "description": "The reallocation options. If LMEM_MODIFY is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object. You can optionally combine LMEM_MODIFY with the following value. If this parameter does not specify LMEM_MODIFY, you can use the following value.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalSize",
            "return_type": "SIZE_T",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localsize",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HLOCAL",
                    "description": "A handle to the local memory object. This handle is returned by the\nLocalAlloc,\nLocalReAlloc, or\nLocalHandle function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocalUnlock",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localunlock",
            "description": "",
            "parameters": [
                {
                    "name": "hMem",
                    "type": "HLOCAL",
                    "description": "A handle to the local memory object. This handle is returned by either the\nLocalAlloc or\nLocalReAlloc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LocateXStateFeature",
            "return_type": "PVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-locatexstatefeature",
            "description": "",
            "parameters": [
                {
                    "name": "Context",
                    "type": "PCONTEXT",
                    "description": "A pointer to a CONTEXT structure containing the state\nto retrieve or set. This CONTEXT should have been\ninitialized with InitializeContext with the\nCONTEXT_XSTATE flag set in the ContextFlags\nparameter.",
                    "possible_constants": []
                },
                {
                    "name": "FeatureId",
                    "type": "DWORD",
                    "description": "The number of the feature to locate within the\nCONTEXT structure. [out, optional] Length A pointer to a variable which receives the length of the feature area in bytes. The contents of this\nvariable are undefined if this function returns NULL.",
                    "possible_constants": []
                },
                {
                    "name": "Length",
                    "type": "PDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LogonUserA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonusera",
            "description": "",
            "parameters": [
                {
                    "name": "lpszUsername",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, User@DNSDomainName, the lpszDomain parameter must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpszDomain",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database.",
                    "possible_constants": []
                },
                {
                    "name": "lpszPassword",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonType",
                    "type": "DWORD",
                    "description": "The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonProvider",
                    "type": "DWORD",
                    "description": "Specifies the logon provider. This parameter can be one of the following values. [out] phToken A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the\nImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the\nCreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUser returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert it to a primary token. When you no longer need this handle, close it by calling the\nCloseHandle function.",
                    "possible_constants": []
                },
                {
                    "name": "phToken",
                    "type": "PHANDLE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LogonUserExA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszUsername",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, user@DNS_domain_name, the lpszDomain parameter must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpszDomain",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database.",
                    "possible_constants": []
                },
                {
                    "name": "lpszPassword",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonType",
                    "type": "DWORD",
                    "description": "The type of logon operation to perform. This parameter can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonProvider",
                    "type": "DWORD",
                    "description": "The logon provider. This parameter can be one of the following values. [out, optional] phToken A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the\nImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the\nCreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUserEx returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert the impersonation token to a primary token. When you no longer need this handle, close it by calling the\nCloseHandle function. [out, optional] ppLogonSid A pointer to a pointer to a security identifier (SID) that receives the SID of the user logged on. When you have finished using the SID, free it by calling the LocalFree function. [out, optional] ppProfileBuffer A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile. [out, optional] pdwProfileLength A pointer to a DWORD that receives the length of the profile buffer. [out, optional] pQuotaLimits A pointer to a QUOTA_LIMITS structure that receives information about the quotas for the logged on user.",
                    "possible_constants": []
                },
                {
                    "name": "phToken",
                    "type": "PHANDLE",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*ppLogonSid",
                    "type": "PSID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*ppProfileBuffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pdwProfileLength",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pQuotaLimits",
                    "type": "PQUOTA_LIMITS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LogonUserExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszUsername",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, user@DNS_domain_name, the lpszDomain parameter must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpszDomain",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database.",
                    "possible_constants": []
                },
                {
                    "name": "lpszPassword",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonType",
                    "type": "DWORD",
                    "description": "The type of logon operation to perform. This parameter can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonProvider",
                    "type": "DWORD",
                    "description": "The logon provider. This parameter can be one of the following values. [out, optional] phToken A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the\nImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the\nCreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUserEx returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert the impersonation token to a primary token. When you no longer need this handle, close it by calling the\nCloseHandle function. [out, optional] ppLogonSid A pointer to a pointer to a security identifier (SID) that receives the SID of the user logged on. When you have finished using the SID, free it by calling the LocalFree function. [out, optional] ppProfileBuffer A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile. [out, optional] pdwProfileLength A pointer to a DWORD that receives the length of the profile buffer. [out, optional] pQuotaLimits A pointer to a QUOTA_LIMITS structure that receives information about the quotas for the logged on user.",
                    "possible_constants": []
                },
                {
                    "name": "phToken",
                    "type": "PHANDLE",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*ppLogonSid",
                    "type": "PSID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*ppProfileBuffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pdwProfileLength",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "pQuotaLimits",
                    "type": "PQUOTA_LIMITS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LogonUserW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonuserw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszUsername",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, User@DNSDomainName, the lpszDomain parameter must be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpszDomain",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database.",
                    "possible_constants": []
                },
                {
                    "name": "lpszPassword",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonType",
                    "type": "DWORD",
                    "description": "The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.",
                    "possible_constants": []
                },
                {
                    "name": "dwLogonProvider",
                    "type": "DWORD",
                    "description": "Specifies the logon provider. This parameter can be one of the following values. [out] phToken A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the\nImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the\nCreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUser returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert it to a primary token. When you no longer need this handle, close it by calling the\nCloseHandle function.",
                    "possible_constants": []
                },
                {
                    "name": "phToken",
                    "type": "PHANDLE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountnamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is NULL, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  lpSystemName only when the  account is in an untrusted domain and the   name of a computer in that domain is known.",
                    "possible_constants": []
                },
                {
                    "name": "lpAccountName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the account name. Use a fully qualified string in the domain_name\\user_name format to ensure that LookupAccountName finds the account in the desired domain. [out, optional] Sid A pointer to a buffer that receives the\nSID structure that corresponds to the account name pointed to by the lpAccountName parameter. If this parameter is NULL, cbSid must be zero.",
                    "possible_constants": []
                },
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to a variable. On input, this value specifies the size, in bytes, of the Sid buffer. If the function fails because the buffer is too small or if cbSid is zero, this variable receives the required buffer size. [out, optional] ReferencedDomainName A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is NULL, the function returns the required buffer size.",
                    "possible_constants": []
                },
                {
                    "name": "cbSid",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPSTR",
                    "description": "A pointer to a variable. On input, this value specifies the size, in TCHARs, of the ReferencedDomainName buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating null character. If the ReferencedDomainName parameter is NULL, this parameter must be zero. [out] peUse A pointer to a\nSID_NAME_USE enumerated type that indicates the type of the account when the function returns.",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountnamew",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is NULL, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  lpSystemName only when the  account is in an untrusted domain and the   name of a computer in that domain is known.",
                    "possible_constants": []
                },
                {
                    "name": "lpAccountName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the account name. Use a fully qualified string in the domain_name\\user_name format to ensure that LookupAccountName finds the account in the desired domain. [out, optional] Sid A pointer to a buffer that receives the\nSID structure that corresponds to the account name pointed to by the lpAccountName parameter. If this parameter is NULL, cbSid must be zero.",
                    "possible_constants": []
                },
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to a variable. On input, this value specifies the size, in bytes, of the Sid buffer. If the function fails because the buffer is too small or if cbSid is zero, this variable receives the required buffer size. [out, optional] ReferencedDomainName A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is NULL, the function returns the required buffer size.",
                    "possible_constants": []
                },
                {
                    "name": "cbSid",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPWSTR",
                    "description": "A pointer to a variable. On input, this value specifies the size, in TCHARs, of the ReferencedDomainName buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating null character. If the ReferencedDomainName parameter is NULL, this parameter must be zero. [out] peUse A pointer to a\nSID_NAME_USE enumerated type that indicates the type of the account when the function returns.",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountSidA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsida",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is NULL, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  lpSystemName only when the  account is in an untrusted domain and the   name of a computer in that domain is known.",
                    "possible_constants": []
                },
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to the\nSID to look up. [out, optional] Name A pointer to a buffer that receives a null-terminated string that contains the account name that corresponds to the lpSid parameter.",
                    "possible_constants": []
                },
                {
                    "name": "Name",
                    "type": "LPSTR",
                    "description": "On input, specifies the size, in TCHARs, of the lpReferencedDomainName buffer. If the function fails because the buffer is too small or if cchReferencedDomainName is zero, cchReferencedDomainName receives the required buffer size, including the terminating null character. [out] peUse A pointer to a variable that receives a\nSID_NAME_USE value that indicates the type of the account.",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountSidLocalA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsidlocala",
            "description": "",
            "parameters": [
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to the\nSID to look up. [out, optional] Name A pointer to a buffer that receives a null-terminated string that contains the account name that corresponds to the lpSid parameter.",
                    "possible_constants": []
                },
                {
                    "name": "Name",
                    "type": "LPSTR",
                    "description": "On input, specifies the size, in TCHARs, of the lpReferencedDomainName buffer. If the function fails because the buffer is too small or if cchReferencedDomainName is zero, cchReferencedDomainName receives the required buffer size, including the terminating null character. [out] peUse A pointer to a variable that receives a\nSID_NAME_USE value that indicates the type of the account.",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountSidLocalW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsidlocalw",
            "description": "",
            "parameters": [
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to the\nSID to look up. [out, optional] Name A pointer to a buffer that receives a null-terminated string that contains the account name that corresponds to the lpSid parameter.",
                    "possible_constants": []
                },
                {
                    "name": "Name",
                    "type": "LPWSTR",
                    "description": "On input, specifies the size, in TCHARs, of the lpReferencedDomainName buffer. If the function fails because the buffer is too small or if cchReferencedDomainName is zero, cchReferencedDomainName receives the required buffer size, including the terminating null character. [out] peUse A pointer to a variable that receives a\nSID_NAME_USE value that indicates the type of the account.",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupAccountSidW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsidw",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is NULL, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  lpSystemName only when the  account is in an untrusted domain and the   name of a computer in that domain is known.",
                    "possible_constants": []
                },
                {
                    "name": "Sid",
                    "type": "PSID",
                    "description": "A pointer to the\nSID to look up. [out, optional] Name A pointer to a buffer that receives a null-terminated string that contains the account name that corresponds to the lpSid parameter.",
                    "possible_constants": []
                },
                {
                    "name": "Name",
                    "type": "LPWSTR",
                    "description": "On input, specifies the size, in TCHARs, of the lpReferencedDomainName buffer. If the function fails because the buffer is too small or if cchReferencedDomainName is zero, cchReferencedDomainName receives the required buffer size, including the terminating null character. [out] peUse A pointer to a variable that receives a\nSID_NAME_USE value that indicates the type of the account.",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReferencedDomainName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchReferencedDomainName",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "peUse",
                    "type": "PSID_NAME_USE",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeDisplayNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegedisplaynamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, \"SeRemoteShutdownPrivilege\". For a list of values, see Privilege Constants. [out, optional] lpDisplayName A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the lpName parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is \"Force shutdown from a remote system.\"",
                    "possible_constants": []
                },
                {
                    "name": "lpDisplayName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchDisplayName",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size, in TCHARs, of the lpDisplayName buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the lpDisplayName parameter is too small, this variable contains the required size. [out] lpLanguageId A pointer to a variable that receives the language identifier for the returned display name.",
                    "possible_constants": []
                },
                {
                    "name": "lpLanguageId",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeDisplayNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegedisplaynamew",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, \"SeRemoteShutdownPrivilege\". For a list of values, see Privilege Constants. [out, optional] lpDisplayName A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the lpName parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is \"Force shutdown from a remote system.\"",
                    "possible_constants": []
                },
                {
                    "name": "lpDisplayName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchDisplayName",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size, in TCHARs, of the lpDisplayName buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the lpDisplayName parameter is too small, this variable contains the required size. [out] lpLanguageId A pointer to a variable that receives the language identifier for the returned display name.",
                    "possible_constants": []
                },
                {
                    "name": "lpLanguageId",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegenamea",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpLuid",
                    "type": "PLUID",
                    "description": "A pointer to the LUID by which the privilege is known on the target system. [out, optional] lpName A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be \"SeSecurityPrivilege\".",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size, in a TCHAR value, of the lpName buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the lpName parameter is too small, this variable contains the required size.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegenamew",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpLuid",
                    "type": "PLUID",
                    "description": "A pointer to the LUID by which the privilege is known on the target system. [out, optional] lpName A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be \"SeSecurityPrivilege\".",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cchName",
                    "type": "LPDWORD",
                    "description": "A pointer to a variable that specifies the size, in a TCHAR value, of the lpName buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the lpName parameter is too small, this variable contains the required size.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeValueA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, \"SeSecurityPrivilege\". [out] lpLuid A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the lpSystemName parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpLuid",
                    "type": "PLUID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "LookupPrivilegeValueW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluew",
            "description": "",
            "parameters": [
                {
                    "name": "lpSystemName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, \"SeSecurityPrivilege\". [out] lpLuid A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the lpSystemName parameter.",
                    "possible_constants": []
                },
                {
                    "name": "lpLuid",
                    "type": "PLUID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcatA",
            "return_type": "LPSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcata",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPSTR",
                    "description": "Type: LPTSTR The first null-terminated string. This buffer must be large enough\nto contain both strings.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCSTR",
                    "description": "Type: LPTSTR The null-terminated string to be appended to the string\nspecified in the lpString1 parameter.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcatW",
            "return_type": "LPWSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcatw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPWSTR",
                    "description": "Type: LPTSTR The first null-terminated string. This buffer must be large enough\nto contain both strings.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCWSTR",
                    "description": "Type: LPTSTR The null-terminated string to be appended to the string\nspecified in the lpString1 parameter.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcmpA",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcmpa",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The first null-terminated string to be compared.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The second null-terminated string to be compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcmpiA",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcmpia",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The first null-terminated string to be compared.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The second null-terminated string to be compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcmpiW",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcmpiw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPCWSTR",
                    "description": "Type: LPCWSTR The first null-terminated string to be compared.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCWSTR",
                    "description": "Type: LPCWSTR The second null-terminated string to be compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcmpW",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcmpw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The first null-terminated string to be compared.",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The second null-terminated string to be compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcpyA",
            "return_type": "LPSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcpya",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCSTR",
                    "description": "Type: LPTSTR The null-terminated string to be copied.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcpynA",
            "return_type": "LPSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcpyna",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The source string from which the function is to copy characters.",
                    "possible_constants": []
                },
                {
                    "name": "iMaxLength",
                    "type": "int",
                    "description": "Type: int The number of TCHAR values to be copied from the\nstring pointed to by lpString2 into the\nbuffer pointed to by lpString1, including\na terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcpynW",
            "return_type": "LPWSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcpynw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The source string from which the function is to copy characters.",
                    "possible_constants": []
                },
                {
                    "name": "iMaxLength",
                    "type": "int",
                    "description": "Type: int The number of TCHAR values to be copied from the\nstring pointed to by lpString2 into the\nbuffer pointed to by lpString1, including\na terminating null character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrcpyW",
            "return_type": "LPWSTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrcpyw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString1",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpString2",
                    "type": "LPCWSTR",
                    "description": "Type: LPTSTR The null-terminated string to be copied.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrlenA",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrlena",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be checked.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "lstrlenW",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lstrlenw",
            "description": "",
            "parameters": [
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The null-terminated string to be checked.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MAKEINTATOM",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-makeintatom",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "MapUserPhysicalPagesScatter",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-mapuserphysicalpagesscatter",
            "description": "",
            "parameters": [
                {
                    "name": "*VirtualAddresses",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "NumberOfPages",
                    "type": "ULONG_PTR",
                    "description": "The size of the physical memory and virtual address space for which to establish translations, in pages. The\narray at VirtualAddresses specifies the virtual address range.",
                    "possible_constants": []
                },
                {
                    "name": "PageArray",
                    "type": "PULONG_PTR",
                    "description": "A pointer to an array of values that indicates how each corresponding page in\nVirtualAddresses should be treated. A 0 (zero) indicates that the corresponding entry in\nVirtualAddresses should be unmapped, and any nonzero value that it has should be mapped. If this parameter is NULL, then every address in the VirtualAddresses array is\nunmapped. The value in NumberOfPages indicates the size of the array.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MapViewOfFileExNuma",
            "return_type": "LPVOID",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-mapviewoffileexnuma",
            "description": "",
            "parameters": [
                {
                    "name": "hFileMappingObject",
                    "type": "HANDLE",
                    "description": "A handle to a file mapping object. The CreateFileMappingNuma and OpenFileMapping functions return this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The type of access to a file mapping object, which determines the page protection of the pages. This parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate. For file-mapping objects created with the SEC_IMAGE attribute, the\ndwDesiredAccess parameter has no effect, and should be set to any valid value such as\nFILE_MAP_READ. For more information  about access to file mapping objects, see\nFile Mapping Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwFileOffsetHigh",
                    "type": "DWORD",
                    "description": "The high-order DWORD of the file offset where the view is to begin.",
                    "possible_constants": []
                },
                {
                    "name": "dwFileOffsetLow",
                    "type": "DWORD",
                    "description": "The low-order DWORD of the file offset where the view is to begin. The\ncombination of the high and low offsets must specify an offset within the file mapping. They must also match the\nmemory allocation granularity of the system. That is, the offset must be a multiple of the allocation\ngranularity. To obtain the memory allocation granularity of the system, use the\nGetSystemInfo function, which fills in the members of\na SYSTEM_INFO structure.",
                    "possible_constants": []
                },
                {
                    "name": "dwNumberOfBytesToMap",
                    "type": "SIZE_T",
                    "description": "The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified\nby CreateFileMapping. If this parameter is 0\n(zero), the mapping extends from the specified offset to the end of the file mapping.",
                    "possible_constants": []
                },
                {
                    "name": "lpBaseAddress",
                    "type": "LPVOID",
                    "description": "A pointer to the memory address in the calling process address space where mapping begins. This must be a\nmultiple of the system's memory allocation granularity, or the function fails. To determine the memory\nallocation granularity of the system, use the\nGetSystemInfo function. If there is not enough\naddress space at the specified address, the function fails. If the lpBaseAddress parameter is NULL, the operating\nsystem chooses the mapping address. While it is possible to specify an address that is safe now (not used by the operating system), there is no\nguarantee that the address will remain safe over time. Therefore, it is better to let the operating system\nchoose the address. In this case, you would not store pointers in the memory mapped file; you would store\noffsets from the base of the file mapping so that the mapping can be used at any address.",
                    "possible_constants": []
                },
                {
                    "name": "nndPreferred",
                    "type": "DWORD",
                    "description": "The NUMA node where the physical memory should reside.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFile",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefile",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCTSTR",
                    "description": "The current name of the file or directory on the local computer. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCTSTR",
                    "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a\ndifferent file system or drive. A new directory must be on the same drive. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The current name of the file or directory on the local computer. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a\ndifferent file system or drive. A new directory must be on the same drive. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileExA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefileexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The current name of the file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the\nfile cannot exist on a remote share, because delayed operations are performed before the network is\navailable. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The new name of the file or directory on the local computer. When moving a file, the destination can be on a different file system or volume. If the destination is on\nanother drive, you must set the MOVEFILE_COPY_ALLOWED flag in\ndwFlags. When moving a directory, the destination must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and\nlpNewFileName is  NULL,\nMoveFileEx registers the\nlpExistingFileName file to be deleted when the system restarts. If\nlpExistingFileName refers to a directory, the system removes the directory at restart\nonly if the directory is empty. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefileexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The current name of the file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the\nfile cannot exist on a remote share, because delayed operations are performed before the network is\navailable. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The new name of the file or directory on the local computer. When moving a file, the destination can be on a different file system or volume. If the destination is on\nanother drive, you must set the MOVEFILE_COPY_ALLOWED flag in\ndwFlags. When moving a directory, the destination must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and\nlpNewFileName is  NULL,\nMoveFileEx registers the\nlpExistingFileName file to be deleted when the system restarts. If\nlpExistingFileName refers to a directory, the system removes the directory at restart\nonly if the directory is empty. In the ANSI version of this function, the name is limited to MAX_PATH characters.\nTo extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend\n\"\\?\" to the path. For more information, see\nNaming a File",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefiletransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The current name of the existing file or directory on the local computer. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a\ndifferent file system or drive. A new directory must be on the same drive. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "A pointer to a CopyProgressRoutine callback\nfunction that is called each time another portion of the file has been moved. The callback function can be\nuseful if you provide a user interface that displays the progress of the operation. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "An argument to be passed to the\nCopyProgressRoutine callback function. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The move options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefiletransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The current name of the existing file or directory on the local computer. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a\ndifferent file system or drive. A new directory must be on the same drive. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "A pointer to a CopyProgressRoutine callback\nfunction that is called each time another portion of the file has been moved. The callback function can be\nuseful if you provide a user interface that displays the progress of the operation. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "An argument to be passed to the\nCopyProgressRoutine callback function. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The move options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The current name of the file or directory on the local computer. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The new name for the file or directory. The new name must not already exist. A new file may be on a\ndifferent file system or drive. A new directory must be on the same drive. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileWithProgressA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefilewithprogressa",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCSTR",
                    "description": "The name of the existing file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the\nfile cannot exist on a remote share because delayed operations are performed before the network is\navailable. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCSTR",
                    "description": "The new name of the file or directory  on the local computer. When moving a file, lpNewFileName can be on a different file system or volume. If\nlpNewFileName is on another drive, you must set the\nMOVEFILE_COPY_ALLOWED flag in dwFlags. When moving a directory, lpExistingFileName and\nlpNewFileName must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and\nlpNewFileName is NULL,\nMoveFileWithProgress registers\nlpExistingFileName to be deleted when the system restarts. The function fails if it\ncannot access the registry to store the information about the delete operation. If\nlpExistingFileName refers to a directory, the system removes the directory at restart\nonly if the directory is empty. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "A pointer to a CopyProgressRoutine callback\nfunction that is called each time another portion of the file has been moved. The callback function can be\nuseful if you provide a user interface that displays the progress of the operation. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "An argument to be passed to the\nCopyProgressRoutine callback function. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The move options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MoveFileWithProgressW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefilewithprogressw",
            "description": "",
            "parameters": [
                {
                    "name": "lpExistingFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the existing file or directory on the local computer. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT, the\nfile cannot exist on a remote share because delayed operations are performed before the network is\navailable. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpNewFileName",
                    "type": "LPCWSTR",
                    "description": "The new name of the file or directory  on the local computer. When moving a file, lpNewFileName can be on a different file system or volume. If\nlpNewFileName is on another drive, you must set the\nMOVEFILE_COPY_ALLOWED flag in dwFlags. When moving a directory, lpExistingFileName and\nlpNewFileName must be on the same drive. If dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and\nlpNewFileName is NULL,\nMoveFileWithProgress registers\nlpExistingFileName to be deleted when the system restarts. The function fails if it\ncannot access the registry to store the information about the delete operation. If\nlpExistingFileName refers to a directory, the system removes the directory at restart\nonly if the directory is empty. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "lpProgressRoutine",
                    "type": "LPPROGRESS_ROUTINE",
                    "description": "A pointer to a CopyProgressRoutine callback\nfunction that is called each time another portion of the file has been moved. The callback function can be\nuseful if you provide a user interface that displays the progress of the operation. This parameter can be\nNULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "An argument to be passed to the\nCopyProgressRoutine callback function. This\nparameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "The move options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "MulDiv",
            "return_type": "int",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-muldiv",
            "description": "",
            "parameters": [
                {
                    "name": "nNumber",
                    "type": "int",
                    "description": "The multiplicand.",
                    "possible_constants": []
                },
                {
                    "name": "nNumerator",
                    "type": "int",
                    "description": "The multiplier.",
                    "possible_constants": []
                },
                {
                    "name": "nDenominator",
                    "type": "int",
                    "description": "The number by which the result of the multiplication operation is to be divided.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "NotifyChangeEventLog",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-notifychangeeventlog",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to an event log. The\nOpenEventLog  function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "hEvent",
                    "type": "HANDLE",
                    "description": "A handle to a manual-reset or auto-reset event object. Use the\nCreateEvent function to create the event object.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ObjectCloseAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-objectcloseauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A unique value representing the client's handle to the object. This should be the same value that was passed to the\nAccessCheckAndAuditAlarm or ObjectOpenAuditAlarm function.",
                    "possible_constants": []
                },
                {
                    "name": "GenerateOnClose",
                    "type": "BOOL",
                    "description": "Specifies a flag set by a call to the AccessCheckAndAuditAlarm or ObjectCloseAuditAlarm function when the object handle is created. If this flag is TRUE, the function generates an audit message. If it is FALSE, the function does not generate an audit message.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ObjectDeleteAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-objectdeleteauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the\nAccessCheckAndAuditAlarm or\nObjectOpenAuditAlarm function.",
                    "possible_constants": []
                },
                {
                    "name": "GenerateOnClose",
                    "type": "BOOL",
                    "description": "Specifies a flag set by a call to the\nAccessCheckAndAuditAlarm or\nObjectOpenAuditAlarm function when the object handle is created.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ObjectOpenAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-objectopenauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored. For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectTypeName",
                    "type": "LPSTR",
                    "description": "A pointer to a null-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectName",
                    "type": "LPSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.",
                    "possible_constants": []
                },
                {
                    "name": "pSecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to the\nSECURITY_DESCRIPTOR structure for the object being accessed.",
                    "possible_constants": []
                },
                {
                    "name": "ClientToken",
                    "type": "HANDLE",
                    "description": "Identifies an access token representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "Specifies the desired access mask. This mask must have been previously mapped by the MapGenericMask function to contain no generic access rights.",
                    "possible_constants": []
                },
                {
                    "name": "GrantedAccess",
                    "type": "DWORD",
                    "description": "Specifies an access mask indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its GrantedAccess parameter. Examples of access-checking functions include AccessCheckAndAuditAlarm and AccessCheck.",
                    "possible_constants": []
                },
                {
                    "name": "Privileges",
                    "type": "PPRIVILEGE_SET",
                    "description": "A pointer to a\nPRIVILEGE_SET structure that specifies the set of privileges required for the access attempt. This parameter can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "ObjectCreation",
                    "type": "BOOL",
                    "description": "Specifies a flag that determines whether the application creates a new object when access is granted. When this value is TRUE, the application creates a new object; when it is FALSE, the application opens an existing object.",
                    "possible_constants": []
                },
                {
                    "name": "AccessGranted",
                    "type": "BOOL",
                    "description": "Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as AccessCheck. If access was granted, this value is TRUE. If not, it is FALSE. [out] GenerateOnClose A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the\nObjectCloseAuditAlarm function when the object handle is closed.",
                    "possible_constants": []
                },
                {
                    "name": "GenerateOnClose",
                    "type": "LPBOOL",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ObjectPrivilegeAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-objectprivilegeauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.",
                    "possible_constants": []
                },
                {
                    "name": "HandleId",
                    "type": "LPVOID",
                    "description": "A pointer to a unique value representing the client's handle to the object.",
                    "possible_constants": []
                },
                {
                    "name": "ClientToken",
                    "type": "HANDLE",
                    "description": "Identifies an access token representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.",
                    "possible_constants": []
                },
                {
                    "name": "DesiredAccess",
                    "type": "DWORD",
                    "description": "Specifies an access mask indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the\nMapGenericMask function so it does not contain any generic access types.",
                    "possible_constants": []
                },
                {
                    "name": "Privileges",
                    "type": "PPRIVILEGE_SET",
                    "description": "A pointer to a\nPRIVILEGE_SET structure containing the privileges that the client attempted to use. The names of the privileges appear in the audit message.",
                    "possible_constants": []
                },
                {
                    "name": "AccessGranted",
                    "type": "BOOL",
                    "description": "Indicates whether the client's attempt to use the privileges was successful. If this value is TRUE, the audit message indicates success. If this value is FALSE, the audit message indicates failure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenBackupEventLogA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openbackupeventloga",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The full path of the backup file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenBackupEventLogW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openbackupeventlogw",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCWSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The full path of the backup file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenCommPort",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-opencommport",
            "description": "",
            "parameters": [
                {
                    "name": "uPortNumber",
                    "type": "ULONG",
                    "description": "A one-based port number for the communication device to open.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The requested access to the device. For more information about requested access, see CreateFile and Creating and Opening Files.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlagsAndAttributes",
                    "type": "DWORD",
                    "description": "The requested flags and attributes to the device.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenEncryptedFileRawA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openencryptedfilerawa",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file to be opened. The string must consist of characters from the Windows character set.",
                    "possible_constants": []
                },
                {
                    "name": "ulFlags",
                    "type": "ULONG",
                    "description": "The operation to be performed. This parameter may be one of the\nfollowing values. [out] pvContext The address of a  context\nblock that must be presented in subsequent calls to\nReadEncryptedFileRaw, WriteEncryptedFileRaw, or\nCloseEncryptedFileRaw.  Do not modify it.",
                    "possible_constants": []
                },
                {
                    "name": "*pvContext",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenEncryptedFileRawW",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openencryptedfileraww",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file to be opened. The string must consist of characters from the Windows character set.",
                    "possible_constants": []
                },
                {
                    "name": "ulFlags",
                    "type": "ULONG",
                    "description": "The operation to be performed. This parameter may be one of the\nfollowing values. [out] pvContext The address of a  context\nblock that must be presented in subsequent calls to\nReadEncryptedFileRaw, WriteEncryptedFileRaw, or\nCloseEncryptedFileRaw.  Do not modify it.",
                    "possible_constants": []
                },
                {
                    "name": "*pvContext",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenEventLogA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openeventloga",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpSourceName",
                    "type": "LPCSTR",
                    "description": "The name of the log. If you specify a custom log and it cannot be found, the event logging service opens the Application log; however, there will be no associated message or category string file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenEventLogW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openeventlogw",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCWSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpSourceName",
                    "type": "LPCWSTR",
                    "description": "The name of the log. If you specify a custom log and it cannot be found, the event logging service opens the Application log; however, there will be no associated message or category string file.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenFile",
            "return_type": "HFILE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfile",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file. The string must consist of characters from the 8-bit Windows character set. The\nOpenFile function does not support Unicode file names or\nopening named pipes. [out] lpReOpenBuff A pointer to the OFSTRUCT structure that receives\ninformation about a file when it is first opened. The structure can be used in subsequent calls to the\nOpenFile function to see an open file. The OFSTRUCT structure contains a path string\nmember with a length that is limited to OFS_MAXPATHNAME characters, which is 128\ncharacters. Because of this, you cannot use the OpenFile\nfunction to open a file with a path length that exceeds 128 characters. The\nCreateFile function does not have this path\nlength limitation.",
                    "possible_constants": []
                },
                {
                    "name": "lpReOpenBuff",
                    "type": "LPOFSTRUCT",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "uStyle",
                    "type": "UINT",
                    "description": "The action to be taken. This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenFileById",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfilebyid",
            "description": "",
            "parameters": [
                {
                    "name": "hVolumeHint",
                    "type": "HANDLE",
                    "description": "A handle to any file on a volume or share on which the file to be opened is stored.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileId",
                    "type": "LPFILE_ID_DESCRIPTOR",
                    "description": "A pointer to a FILE_ID_DESCRIPTOR that identifies\nthe file to open.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access to the object. Access can be read, write, or both. For more information, see\nFile Security and Access\nRights. You cannot request an access mode that conflicts with the sharing mode that is specified in an\nopen request that has an open handle. If this parameter is zero (0), the application can query file and device attributes without accessing a\ndevice. This is useful for an application to determine the size of a floppy disk drive and the formats it\nsupports without requiring a floppy in a drive. It can also be used to test for the existence of a file or\ndirectory without opening them for read or write access.",
                    "possible_constants": []
                },
                {
                    "name": "dwShareMode",
                    "type": "DWORD",
                    "description": "The sharing mode of an object, which can be read, write, both, or none. You cannot request a sharing mode that conflicts with the access mode that is specified in an open request\nthat has an open handle, because that would result in the following sharing violation:\n(ERROR_SHARING_VIOLATION). For more information, see\nCreating and Opening Files. If this parameter is zero (0) and OpenFileById\nsucceeds, the object cannot be shared and cannot be opened again until the handle is closed. For more\ninformation, see the Remarks section of this topic. The sharing options remain in effect until you close the handle to an object. To enable a processes to share an object while another process has the object open, use a combination of one\nor more of the following values to specify the access mode they can request to open the object.",
                    "possible_constants": []
                },
                {
                    "name": "lpSecurityAttributes",
                    "type": "LPSECURITY_ATTRIBUTES",
                    "description": "Reserved.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlagsAndAttributes",
                    "type": "DWORD",
                    "description": "The file flags. When OpenFileById opens a file, it combines the file\nflags with existing file attributes, and ignores any supplied file attributes. This parameter can include any\ncombination of the following flags.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenFileMappingA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfilemappinga",
            "description": "",
            "parameters": [
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access to the file mapping object. This access is checked against any security descriptor on the target\nfile mapping object. For a list of values, see\nFile Mapping Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "bInheritHandle",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, a process created by the\nCreateProcess function can inherit the handle;\notherwise, the handle cannot be inherited.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the file mapping object to be opened. If there is an open handle to a file mapping object by\nthis name and the security descriptor on the mapping object does not conflict with the\ndwDesiredAccess parameter, the open operation succeeds. The name can have a\n\"Global\\\" or \"Local\\\" prefix to explicitly open an object in the global or\nsession namespace. The remainder of the name can contain any character except the backslash character (\\). For\nmore information, see\nKernel Object Namespaces. Fast user\nswitching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next\nuser to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal\nServices so that applications can support multiple users.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenJobObjectA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openjobobjecta",
            "description": "",
            "parameters": [
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The access to the job object. This parameter can be one or more of the\njob object access rights. This access right is checked against any security descriptor for the object.",
                    "possible_constants": []
                },
                {
                    "name": "bInheritHandle",
                    "type": "BOOL",
                    "description": "If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the job to be opened. Name comparisons are case sensitive. This function can open objects in a private namespace. For more information, see Object Namespaces. Terminal Services:\u00a0\u00a0The name can have a \"Global\" or \"Local\" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\\). For more information, see\nKernel Object Namespaces.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OpenPrivateNamespaceA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openprivatenamespacea",
            "description": "",
            "parameters": [
                {
                    "name": "lpBoundaryDescriptor",
                    "type": "LPVOID",
                    "description": "A descriptor that defines how the namespace is to be isolated. The CreateBoundaryDescriptor function creates a boundary descriptor.",
                    "possible_constants": []
                },
                {
                    "name": "lpAliasPrefix",
                    "type": "LPCSTR",
                    "description": "The prefix for the namespace. To create an object in this namespace, specify the object name as prefix\\objectname.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OperationEnd",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-operationend",
            "description": "",
            "parameters": [
                {
                    "name": "*OperationEndParams",
                    "type": "OPERATION_END_PARAMETERS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "OperationStart",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-operationstart",
            "description": "",
            "parameters": [
                {
                    "name": "*OperationStartParams",
                    "type": "OPERATION_START_PARAMETERS",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PowerClearRequest",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-powerclearrequest",
            "description": "",
            "parameters": [
                {
                    "name": "PowerRequest",
                    "type": "HANDLE",
                    "description": "A handle to a power request object.",
                    "possible_constants": []
                },
                {
                    "name": "RequestType",
                    "type": "POWER_REQUEST_TYPE",
                    "description": "The power request type to be decremented. This parameter can be one of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PowerCreateRequest",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-powercreaterequest",
            "description": "",
            "parameters": [
                {
                    "name": "Context",
                    "type": "PREASON_CONTEXT",
                    "description": "Points to a REASON_CONTEXT structure that contains information about the power request.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PowerSetRequest",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-powersetrequest",
            "description": "",
            "parameters": [
                {
                    "name": "PowerRequest",
                    "type": "HANDLE",
                    "description": "A handle to a power request object.",
                    "possible_constants": []
                },
                {
                    "name": "RequestType",
                    "type": "POWER_REQUEST_TYPE",
                    "description": "The power request type to be incremented. This parameter can be one of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PrepareTape",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-preparetape",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device preparing the tape. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwOperation",
                    "type": "DWORD",
                    "description": "Tape device preparation. This parameter can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "bImmediate",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the function returns immediately. If it is FALSE, the function does not return until the operation has been completed.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PrivilegedServiceAuditAlarmA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-privilegedserviceauditalarma",
            "description": "",
            "parameters": [
                {
                    "name": "SubsystemName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.",
                    "possible_constants": []
                },
                {
                    "name": "ServiceName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.",
                    "possible_constants": []
                },
                {
                    "name": "ClientToken",
                    "type": "HANDLE",
                    "description": "Identifies an access token representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.",
                    "possible_constants": []
                },
                {
                    "name": "Privileges",
                    "type": "PPRIVILEGE_SET",
                    "description": "A pointer to a\nPRIVILEGE_SET structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.",
                    "possible_constants": []
                },
                {
                    "name": "AccessGranted",
                    "type": "BOOL",
                    "description": "Indicates whether the client's attempt to use the privileges was successful. If this value is TRUE, the security event log record indicates success. If this value is FALSE, the security event log record indicates failure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PulseEvent",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent",
            "description": "",
            "parameters": [
                {
                    "name": "hEvent",
                    "type": "HANDLE",
                    "description": "A handle to the event object. The\nCreateEvent or\nOpenEvent function returns this handle. The handle must have the EVENT_MODIFY_STATE access right. For more information, see\nSynchronization Object Security and Access Rights.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "PurgeComm",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-purgecomm",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications resource. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryActCtxSettingsW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-queryactctxsettingsw",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This value must be 0.",
                    "possible_constants": []
                },
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "A handle to the activation context that is being queried.",
                    "possible_constants": []
                },
                {
                    "name": "settingsNameSpace",
                    "type": "PCWSTR",
                    "description": "A pointer to a string that contains the value \"http://schemas.microsoft.com/SMI/2005/WindowsSettings\" or NULL. These values are equivalent. Windows\u00a08 and Windows Server\u00a02012:\u00a0\u00a0A pointer to a string that contains the value \"http://schemas.microsoft.com/SMI/2011/WindowsSettings\" is also a valid parameter.  A NULL is still equivalent to the previous value.",
                    "possible_constants": []
                },
                {
                    "name": "settingName",
                    "type": "PCWSTR",
                    "description": "The name of the attribute to be queried. [out] pvBuffer A pointer to the buffer that receives the query result.",
                    "possible_constants": []
                },
                {
                    "name": "pvBuffer",
                    "type": "PWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "dwBuffer",
                    "type": "SIZE_T",
                    "description": "The size of the buffer  in characters that receives the query result. [out, optional] pdwWrittenOrRequired A pointer to a value which is the number of characters written to the buffer specified by pvBuffer or that is required to hold the query result.",
                    "possible_constants": []
                },
                {
                    "name": "*pdwWrittenOrRequired",
                    "type": "SIZE_T",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryActCtxW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-queryactctxw",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter should be set to one of the following flag bits.",
                    "possible_constants": []
                },
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "Handle to the activation context that is being queried.",
                    "possible_constants": []
                },
                {
                    "name": "pvSubInstance",
                    "type": "PVOID",
                    "description": "Index of the assembly, or assembly and file combination, in the activation context. The meaning of the pvSubInstance depends on the option specified by the value of the ulInfoClass parameter. This parameter may be null.",
                    "possible_constants": []
                },
                {
                    "name": "ulInfoClass",
                    "type": "ULONG",
                    "description": "This parameter can have only the values shown in the following table. [out] pvBuffer Pointer to a buffer that holds the returned information. This parameter is optional. If pvBuffer is null, then cbBuffer must be zero. If the size of the buffer pointed to by pvBuffer is too small,\nQueryActCtxW returns ERROR_INSUFFICIENT_BUFFER and no data is written into the buffer. See the Remarks section for the method you can use to determine the required size of the buffer.",
                    "possible_constants": []
                },
                {
                    "name": "pvBuffer",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "cbBuffer",
                    "type": "SIZE_T",
                    "description": "Size of the buffer in bytes pointed to by pvBuffer. This parameter is optional. [out, optional] pcbWrittenOrRequired Number of bytes written or required. The parameter pcbWrittenOrRequired can only be NULL when pvBuffer is NULL. If pcbWrittenOrRequired is non-NULL, it is filled with the number of bytes required to store the returned buffer.",
                    "possible_constants": []
                },
                {
                    "name": "*pcbWrittenOrRequired",
                    "type": "SIZE_T",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryDosDeviceA",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-querydosdevicea",
            "description": "",
            "parameters": [
                {
                    "name": "lpDeviceName",
                    "type": "LPCSTR",
                    "description": "An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing\nbackslash; for example, use \"C:\", not \"C:\\\". This parameter can be NULL. In that case, the\nQueryDosDevice function will store a list of all\nexisting MS-DOS device names into the buffer pointed to by lpTargetPath. [out] lpTargetPath A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or\nmore null-terminated strings. The final null-terminated string is followed by an additional\nNULL. If lpDeviceName is non-NULL, the function retrieves\ninformation about the particular MS-DOS device specified by lpDeviceName. The first\nnull-terminated string stored into the buffer is the current mapping for the device. The other null-terminated\nstrings represent undeleted prior mappings for the device. If lpDeviceName is NULL, the function retrieves a list of\nall existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing\nMS-DOS device, for example, \\Device\\HarddiskVolume1 or \\Device\\Floppy0.",
                    "possible_constants": []
                },
                {
                    "name": "lpTargetPath",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ucchMax",
                    "type": "DWORD",
                    "description": "The maximum number of TCHARs that can be stored into the buffer pointed to by\nlpTargetPath.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryFullProcessImageNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-queryfullprocessimagenamea",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see\nProcess Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be one of the following values. [out] lpExeName The path to the executable image. If the function succeeds, this string is null-terminated.",
                    "possible_constants": []
                },
                {
                    "name": "lpExeName",
                    "type": "LPSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "PDWORD",
                    "description": "On input, specifies the size of the lpExeName buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryFullProcessImageNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-queryfullprocessimagenamew",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see\nProcess Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be one of the following values. [out] lpExeName The path to the executable image. If the function succeeds, this string is null-terminated.",
                    "possible_constants": []
                },
                {
                    "name": "lpExeName",
                    "type": "LPWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpdwSize",
                    "type": "PDWORD",
                    "description": "On input, specifies the size of the lpExeName buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryThreadProfiling",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-querythreadprofiling",
            "description": "",
            "parameters": [
                {
                    "name": "ThreadHandle",
                    "type": "HANDLE",
                    "description": "The handle to the thread of interest. [out] Enabled Is TRUE if thread profiling is enabled for the specified thread; otherwise, FALSE.",
                    "possible_constants": []
                },
                {
                    "name": "Enabled",
                    "type": "PBOOLEAN",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "QueryUmsThreadInformation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-queryumsthreadinformation",
            "description": "",
            "parameters": [
                {
                    "name": "UmsThread",
                    "type": "PUMS_CONTEXT",
                    "description": "The size of the UmsThreadInformation buffer, in bytes. [out, optional] ReturnLength A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the UmsThreadInformation buffer.",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInfoClass",
                    "type": "UMS_THREAD_INFO_CLASS",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInformation",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInformationLength",
                    "type": "ULONG",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "ReturnLength",
                    "type": "PULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadDirectoryChangesExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readdirectorychangesexw",
            "description": "",
            "parameters": [
                {
                    "name": "hDirectory",
                    "type": "HANDLE",
                    "description": "A handle to the directory to be monitored. This directory must be opened with the\nFILE_LIST_DIRECTORY access right, or an access right such as GENERIC_READ that includes the FILE_LIST_DIRECTORY access right. [out] lpBuffer A pointer to the DWORD-aligned formatted buffer in which ReadDirectoryChangesExW should return the read results. The structure of this buffer is defined by the\nFILE_NOTIFY_EXTENDED_INFORMATION structure if the value of the ReadDirectoryNotifyInformationClass parameter is ReadDirectoryNotifyExtendedInformation, or by the FILE_NOTIFY_INFORMATION structure if ReadDirectoryNotifyInformationClass is ReadDirectoryNotifyInformation. This\nbuffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value\nis given to the lpOverlapped parameter. For more information, see the Remarks\nsection.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the buffer to which the lpBuffer parameter points, in\nbytes.",
                    "possible_constants": []
                },
                {
                    "name": "bWatchSubtree",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the function monitors the directory tree rooted at the\nspecified directory. If this parameter is FALSE, the function monitors only the\ndirectory specified by the hDirectory parameter.",
                    "possible_constants": []
                },
                {
                    "name": "dwNotifyFilter",
                    "type": "DWORD",
                    "description": "The filter criteria that the function checks to determine if the wait operation has completed. This\nparameter can be one or more of the following values. [out, optional] lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the\nlpBuffer parameter. For asynchronous calls, this parameter is undefined. You must use\nan asynchronous notification technique to retrieve the number of bytes transferred.",
                    "possible_constants": []
                },
                {
                    "name": "lpBytesReturned",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpOverlapped",
                    "type": "LPOVERLAPPED",
                    "description": "A pointer to an OVERLAPPED structure that supplies\ndata to be used during asynchronous operation. Otherwise, this value is NULL. The\nOffset and OffsetHigh members of this structure are not\nused.",
                    "possible_constants": []
                },
                {
                    "name": "lpCompletionRoutine",
                    "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
                    "description": "A pointer to a completion routine to be called when the operation has been completed or canceled and the\ncalling thread is in an alertable wait state. For more information about this completion routine, see\nFileIOCompletionRoutine.",
                    "possible_constants": []
                },
                {
                    "name": "ReadDirectoryNotifyInformationClass",
                    "type": "READ_DIRECTORY_NOTIFY_INFORMATION_CLASS",
                    "description": "The type of   information that\nReadDirectoryChangesExW should write to the buffer to which the lpBuffer parameter points. Specify ReadDirectoryNotifyInformation to indicate\nthat the information should consist of FILE_NOTIFY_INFORMATION structures, or ReadDirectoryNotifyExtendedInformation to indicate\nthat the information should consist of FILE_NOTIFY_EXTENDED_INFORMATION structures.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadDirectoryChangesW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readdirectorychangesw",
            "description": "",
            "parameters": [
                {
                    "name": "hDirectory",
                    "type": "HANDLE",
                    "description": "A handle to the directory to be monitored. This directory must be opened with the\nFILE_LIST_DIRECTORY access right, or an access right such as GENERIC_READ that includes the FILE_LIST_DIRECTORY access right. [out] lpBuffer A pointer to the DWORD-aligned formatted buffer in which the read results are\nto be returned. The structure of this buffer is defined by the\nFILE_NOTIFY_INFORMATION structure. This\nbuffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value\nis given to the lpOverlapped parameter. For more information, see the Remarks\nsection.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nBufferLength",
                    "type": "DWORD",
                    "description": "The size of the buffer that is pointed to by the lpBuffer parameter, in\nbytes.",
                    "possible_constants": []
                },
                {
                    "name": "bWatchSubtree",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the function monitors the directory tree rooted at the\nspecified directory. If this parameter is FALSE, the function monitors only the\ndirectory specified by the hDirectory parameter.",
                    "possible_constants": []
                },
                {
                    "name": "dwNotifyFilter",
                    "type": "DWORD",
                    "description": "The filter criteria that the function checks to determine if the wait operation has completed. This\nparameter can be one or more of the following values. [out, optional] lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the\nlpBuffer parameter. For asynchronous calls, this parameter is undefined. You must use\nan asynchronous notification technique to retrieve the number of bytes transferred.",
                    "possible_constants": []
                },
                {
                    "name": "lpBytesReturned",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpOverlapped",
                    "type": "LPOVERLAPPED",
                    "description": "A pointer to an OVERLAPPED structure that supplies\ndata to be used during asynchronous operation. Otherwise, this value is NULL. The\nOffset and OffsetHigh members of this structure are not\nused.",
                    "possible_constants": []
                },
                {
                    "name": "lpCompletionRoutine",
                    "type": "LPOVERLAPPED_COMPLETION_ROUTINE",
                    "description": "A pointer to a completion routine to be called when the operation has been completed or canceled and the\ncalling thread is in an alertable wait state. For more information about this completion routine, see\nFileIOCompletionRoutine.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadEncryptedFileRaw",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readencryptedfileraw",
            "description": "",
            "parameters": [
                {
                    "name": "pfExportCallback",
                    "type": "PFE_EXPORT_FUNC",
                    "description": "A pointer to the export callback function. The system calls the callback function multiple times, each time\npassing a block of the file's data to the callback function until the entire file has been read. For more\ninformation, see ExportCallback.",
                    "possible_constants": []
                },
                {
                    "name": "pvCallbackContext",
                    "type": "PVOID",
                    "description": "A pointer to an application-defined and allocated context block. The system passes this pointer to the\ncallback function as a parameter so that the callback function can have access to application-specific data.\nThis can be a structure and can contain any data the application needs, such as the handle to the file that will\ncontain the backup copy of the encrypted file.",
                    "possible_constants": []
                },
                {
                    "name": "pvContext",
                    "type": "PVOID",
                    "description": "A pointer to a system-defined context block. The context block is returned by the\nOpenEncryptedFileRaw function. Do not modify\nit.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadEventLogA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readeventloga",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log to be read. The\nOpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwReadFlags",
                    "type": "DWORD",
                    "description": "Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive). You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).",
                    "possible_constants": []
                },
                {
                    "name": "dwRecordOffset",
                    "type": "DWORD",
                    "description": "The record number of the log-entry at which the read operation should start. This parameter is ignored unless dwReadFlags includes the EVENTLOG_SEEK_READ flag. [out] lpBuffer An application-allocated buffer that will receive one or more EVENTLOGRECORD structures. This parameter cannot be NULL, even if the nNumberOfBytesToRead parameter is zero. The maximum size of this buffer is 0x7ffff bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nNumberOfBytesToRead",
                    "type": "DWORD",
                    "description": "The size of the lpBuffer buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries. [out] pnBytesRead A pointer to a variable that receives the number of bytes read by the function. [out] pnMinNumberOfBytesNeeded A pointer to a variable that receives the required size of the lpBuffer buffer. This value is valid only if this function returns zero and\nGetLastError returns ERROR_INSUFFICIENT_BUFFER.",
                    "possible_constants": []
                },
                {
                    "name": "*pnBytesRead",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*pnMinNumberOfBytesNeeded",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadEventLogW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readeventlogw",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log to be read. The\nOpenEventLog function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwReadFlags",
                    "type": "DWORD",
                    "description": "Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive). You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).",
                    "possible_constants": []
                },
                {
                    "name": "dwRecordOffset",
                    "type": "DWORD",
                    "description": "The record number of the log-entry at which the read operation should start. This parameter is ignored unless dwReadFlags includes the EVENTLOG_SEEK_READ flag. [out] lpBuffer An application-allocated buffer that will receive one or more EVENTLOGRECORD structures. This parameter cannot be NULL, even if the nNumberOfBytesToRead parameter is zero. The maximum size of this buffer is 0x7ffff bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpBuffer",
                    "type": "LPVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "nNumberOfBytesToRead",
                    "type": "DWORD",
                    "description": "The size of the lpBuffer buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries. [out] pnBytesRead A pointer to a variable that receives the number of bytes read by the function. [out] pnMinNumberOfBytesNeeded A pointer to a variable that receives the required size of the lpBuffer buffer. This value is valid only this function returns zero and\nGetLastError returns ERROR_INSUFFICIENT_BUFFER.",
                    "possible_constants": []
                },
                {
                    "name": "*pnBytesRead",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "*pnMinNumberOfBytesNeeded",
                    "type": "DWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReadThreadProfilingData",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-readthreadprofilingdata",
            "description": "",
            "parameters": [
                {
                    "name": "PerformanceDataHandle",
                    "type": "HANDLE",
                    "description": "The handle that the EnableThreadProfiling function returned.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "One or more of the following flags that specify the counter data to read. The flags must have been set when you called the EnableThreadProfiling function. [out] PerformanceData A PERFORMANCE_DATA structure that contains the thread profiling and hardware counter data.",
                    "possible_constants": []
                },
                {
                    "name": "PerformanceData",
                    "type": "PPERFORMANCE_DATA",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RegisterApplicationRecoveryCallback",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registerapplicationrecoverycallback",
            "description": "",
            "parameters": [
                {
                    "name": "pRecoveyCallback",
                    "type": "APPLICATION_RECOVERY_CALLBACK",
                    "description": "A pointer to the recovery callback function. For more information, see ApplicationRecoveryCallback.",
                    "possible_constants": []
                },
                {
                    "name": "pvParameter",
                    "type": "PVOID",
                    "description": "A pointer to a variable to be passed to the callback function. Can be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "dwPingInterval",
                    "type": "DWORD",
                    "description": "The recovery ping interval, in milliseconds. By default, the interval is 5 seconds (RECOVERY_DEFAULT_PING_INTERVAL). The maximum interval is 5 minutes. If you specify zero, the default interval is used. You must call the ApplicationRecoveryInProgress function within the specified interval to indicate to ARR that you are still actively recovering; otherwise, WER terminates recovery. Typically, you perform recovery in a loop with each iteration lasting no longer than the ping interval. Each iteration performs a block of recovery work followed by a call to ApplicationRecoveryInProgress. Since you also use ApplicationRecoveryInProgress to determine if the user wants to cancel recovery, you should consider a smaller interval, so you do not perform a lot of work unnecessarily.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "Reserved for future use. Set to zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RegisterApplicationRestart",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registerapplicationrestart",
            "description": "",
            "parameters": [
                {
                    "name": "pwzCommandline",
                    "type": "PCWSTR",
                    "description": "A pointer to a Unicode string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you. If this parameter is NULL or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around the argument.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "This parameter can be 0 or one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RegisterEventSourceA",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registereventsourcea",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpSourceName",
                    "type": "LPCSTR",
                    "description": "The name of the event source whose handle is to be retrieved. The source name must be a subkey of a log under the Eventlog registry key.\nNote that the Security log is for system use only.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RegisterEventSourceW",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registereventsourcew",
            "description": "",
            "parameters": [
                {
                    "name": "lpUNCServerName",
                    "type": "LPCWSTR",
                    "description": "The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is NULL, the local computer is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpSourceName",
                    "type": "LPCWSTR",
                    "description": "The name of the event source whose handle is to be retrieved. The source name must be a subkey of a log under the Eventlog registry key.\nNote that the Security log is for system use only.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RegisterWaitForSingleObject",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject",
            "description": "",
            "parameters": [
                {
                    "name": "phNewWaitObject",
                    "type": "PHANDLE",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "hObject",
                    "type": "HANDLE",
                    "description": "A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section. Mutex is not supported. If a handle to a mutex is passed in, the thread pool raises a STATUS_THREADPOOL_HANDLE_EXCEPTION exception and ExceptionRecord.ExceptionInformation[0] will be equal to STATUS_INVALID_PARAMETER_3. If this handle is closed while the wait is still pending, the function's behavior is undefined. The handles must have the SYNCHRONIZE access right. For more information, see\nStandard Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "Callback",
                    "type": "WAITORTIMERCALLBACK",
                    "description": "A pointer to the application-defined function of type WAITORTIMERCALLBACK to be executed when hObject is in the signaled state, or dwMilliseconds elapses. For more information, see\nWaitOrTimerCallback.",
                    "possible_constants": []
                },
                {
                    "name": "Context",
                    "type": "PVOID",
                    "description": "A single value that is passed to the callback function.",
                    "possible_constants": []
                },
                {
                    "name": "dwMilliseconds",
                    "type": "ULONG",
                    "description": "The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled. If dwMilliseconds is zero, the function tests the object's state and returns immediately. If dwMilliseconds is INFINITE, the function's time-out interval never elapses.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlags",
                    "type": "ULONG",
                    "description": "This parameter can be one or more of the following values. For information about using these values with objects that remain signaled, see the Remarks section.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReleaseActCtx",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-releaseactctx",
            "description": "",
            "parameters": [
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "Handle to the\nACTCTX structure that contains information on the activation context for which the reference count is to be decremented.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RemoveDirectoryTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-removedirectorytransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCSTR",
                    "description": "The path of the directory to be removed. The path must specify an empty directory, and the calling process\nmust have delete access to the directory. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The directory must reside on the local computer; otherwise, the function fails and the last error code is set\nto ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RemoveDirectoryTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-removedirectorytransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCWSTR",
                    "description": "The path of the directory to be removed. The path must specify an empty directory, and the calling process\nmust have delete access to the directory. The directory must reside on the local computer; otherwise, the function fails and the last error code is set\nto ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RemoveSecureMemoryCacheCallback",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-removesecurememorycachecallback",
            "description": "",
            "parameters": [
                {
                    "name": "pfnCallBack",
                    "type": "PSECURE_MEMORY_CACHE_CALLBACK",
                    "description": "A pointer to the application-defined SecureMemoryCacheCallback function to remove.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReOpenFile",
            "return_type": "HANDLE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-reopenfile",
            "description": "",
            "parameters": [
                {
                    "name": "hOriginalFile",
                    "type": "HANDLE",
                    "description": "A handle to the object to be reopened. The object must have been created by the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwDesiredAccess",
                    "type": "DWORD",
                    "description": "The required access to the object. For a list of values, see\nFile Security and Access Rights. You\ncannot request an access mode that conflicts with the sharing mode specified in a previous open request whose\nhandle is still open. If this parameter is zero (0), the application can query device attributes without accessing the device. This\nis useful if an application wants to determine the size of a floppy disk drive and the formats it supports\nwithout requiring a floppy in the drive.",
                    "possible_constants": []
                },
                {
                    "name": "dwShareMode",
                    "type": "DWORD",
                    "description": "The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode\nspecified in a previous open request whose handle is still open. If this parameter is zero (0) and CreateFile succeeds,\nthe object cannot be shared and cannot be opened again until the handle is closed. To enable other processes to share the object while your process has it open, use a combination of one or\nmore of the following values to specify the type of access they can request when they open the object. These\nsharing options remain in effect until you close the handle to the object.",
                    "possible_constants": []
                },
                {
                    "name": "dwFlagsAndAttributes",
                    "type": "DWORD",
                    "description": "The file flags. This parameter can be one or more of the following values. If the handle represents the client side of a named pipe, the dwFlags parameter can\nalso contain Security Quality of Service information. For more information, see\nImpersonation Levels. When the calling\napplication specifies the SECURITY_SQOS_PRESENT flag, the\ndwFlags parameter can contain one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReplaceFileA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-replacefilea",
            "description": "",
            "parameters": [
                {
                    "name": "lpReplacedFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file to be replaced. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. This file is opened with the GENERIC_READ, DELETE, and\nSYNCHRONIZE access rights. The sharing mode is\nFILE_SHARE_READ | FILE_SHARE_WRITE |\nFILE_SHARE_DELETE. The caller must have write access to the file to be replaced. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "lpReplacementFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file that will replace the lpReplacedFileName file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The function attempts to open this file with the SYNCHRONIZE,\nGENERIC_READ, GENERIC_WRITE,\nDELETE, and WRITE_DAC access rights so that it can preserve\nall attributes and ACLs. If this fails, the function attempts to open the file with the\nSYNCHRONIZE, GENERIC_READ,\nDELETE, and WRITE_DAC access rights. No sharing mode is\nspecified.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file that will serve as a backup copy of the lpReplacedFileName\nfile. If this parameter is NULL, no backup file is created. See the Remarks section for implementation details on the backup file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwReplaceFlags",
                    "type": "DWORD",
                    "description": "The replacement options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpExclude",
                    "type": "LPVOID",
                    "description": " Reserved for future use.",
                    "possible_constants": []
                },
                {
                    "name": "lpReserved",
                    "type": "LPVOID",
                    "description": " Reserved for future use.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReplaceFileW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-replacefilew",
            "description": "",
            "parameters": [
                {
                    "name": "lpReplacedFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file to be replaced. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. This file is opened with the GENERIC_READ, DELETE, and\nSYNCHRONIZE access rights. The sharing mode is\nFILE_SHARE_READ | FILE_SHARE_WRITE |\nFILE_SHARE_DELETE. The caller must have write access to the file to be replaced. For more information, see\nFile Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "lpReplacementFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file that will replace the lpReplacedFileName file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The function attempts to open this file with the SYNCHRONIZE,\nGENERIC_READ, GENERIC_WRITE,\nDELETE, and WRITE_DAC access rights so that it can preserve\nall attributes and ACLs. If this fails, the function attempts to open the file with the\nSYNCHRONIZE, GENERIC_READ,\nDELETE, and WRITE_DAC access rights. No sharing mode is\nspecified.",
                    "possible_constants": []
                },
                {
                    "name": "lpBackupFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file that will serve as a backup copy of the lpReplacedFileName\nfile. If this parameter is NULL, no backup file is created. See the Remarks section for implementation details on the backup file. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwReplaceFlags",
                    "type": "DWORD",
                    "description": "The replacement options. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpExclude",
                    "type": "LPVOID",
                    "description": " Reserved for future use.",
                    "possible_constants": []
                },
                {
                    "name": "lpReserved",
                    "type": "LPVOID",
                    "description": " Reserved for future use.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReportEventA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-reporteventa",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log. The\nRegisterEventSource function returns this handle. As of Windows\u00a0XP with SP2, this parameter cannot be a handle to the Security log. To write an event to the Security log, use the AuthzReportSecurityEvent function.",
                    "possible_constants": []
                },
                {
                    "name": "wType",
                    "type": "WORD",
                    "description": "The type of event to be logged. This parameter can be one of the following values. For more information about event types, see\nEvent Types.",
                    "possible_constants": []
                },
                {
                    "name": "wCategory",
                    "type": "WORD",
                    "description": "The event category. This is source-specific information; the category can have any value. For more information, see\nEvent Categories.",
                    "possible_constants": []
                },
                {
                    "name": "dwEventID",
                    "type": "DWORD",
                    "description": "The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see Event Identifiers.",
                    "possible_constants": []
                },
                {
                    "name": "lpUserSid",
                    "type": "PSID",
                    "description": "A pointer to the current user's security identifier. This parameter can be NULL if the security identifier is not required.",
                    "possible_constants": []
                },
                {
                    "name": "wNumStrings",
                    "type": "WORD",
                    "description": "The number of insert strings in the array pointed to by the lpStrings parameter. A value of zero indicates that no strings are present.",
                    "possible_constants": []
                },
                {
                    "name": "dwDataSize",
                    "type": "DWORD",
                    "description": "The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present. [in] lpStrings A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or NULL), even if wNumStrings is zero. Each string is limited to 31,839  characters. Prior to Windows\u00a0Vista:\u00a0\u00a0Each string is limited to 32K characters.",
                    "possible_constants": []
                },
                {
                    "name": "*lpStrings",
                    "type": "LPCSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpRawData",
                    "type": "LPVOID",
                    "description": "A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or NULL), even if the dwDataSize parameter is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "ReportEventW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-reporteventw",
            "description": "",
            "parameters": [
                {
                    "name": "hEventLog",
                    "type": "HANDLE",
                    "description": "A handle to the event log. The\nRegisterEventSource function returns this handle. As of Windows\u00a0XP with SP2, this parameter cannot be a handle to the Security log. To write an event to the Security log, use the AuthzReportSecurityEvent function.",
                    "possible_constants": []
                },
                {
                    "name": "wType",
                    "type": "WORD",
                    "description": "The type of event to be logged. This parameter can be one of the following values. For more information about event types, see\nEvent Types.",
                    "possible_constants": []
                },
                {
                    "name": "wCategory",
                    "type": "WORD",
                    "description": "The event category. This is source-specific information; the category can have any value. For more information, see\nEvent Categories.",
                    "possible_constants": []
                },
                {
                    "name": "dwEventID",
                    "type": "DWORD",
                    "description": "The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see Event Identifiers.",
                    "possible_constants": []
                },
                {
                    "name": "lpUserSid",
                    "type": "PSID",
                    "description": "A pointer to the current user's security identifier. This parameter can be NULL if the security identifier is not required.",
                    "possible_constants": []
                },
                {
                    "name": "wNumStrings",
                    "type": "WORD",
                    "description": "The number of insert strings in the array pointed to by the lpStrings parameter. A value of zero indicates that no strings are present.",
                    "possible_constants": []
                },
                {
                    "name": "dwDataSize",
                    "type": "DWORD",
                    "description": "The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present. [in] lpStrings A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or NULL), even if wNumStrings is zero. Each string is limited to 31,839  characters. Prior to Windows\u00a0Vista:\u00a0\u00a0Each string is limited to 32K characters.",
                    "possible_constants": []
                },
                {
                    "name": "*lpStrings",
                    "type": "LPCWSTR",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpRawData",
                    "type": "LPVOID",
                    "description": "A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or NULL), even if the dwDataSize parameter is zero.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "RequestWakeupLatency",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-requestwakeuplatency",
            "description": "",
            "parameters": [
                {
                    "name": "latency",
                    "type": "LATENCY_TIME",
                    "description": "The latency requirement for the time is takes to wake the computer. This parameter can be one of the\nfollowing values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCommBreak",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommbreak",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCommConfig",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommconfig",
            "description": "",
            "parameters": [
                {
                    "name": "hCommDev",
                    "type": "HANDLE",
                    "description": "A handle to the open communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "A pointer to a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "dwSize",
                    "type": "DWORD",
                    "description": "The size of the structure pointed to by lpCC, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCommMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommmask",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwEvtMask",
                    "type": "DWORD",
                    "description": "The events to be enabled. A value of zero disables all events. This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCommState",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommstate",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpDCB",
                    "type": "LPDCB",
                    "description": "A pointer to a\nDCB structure that contains the configuration information for the specified communications device.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCommTimeouts",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommtimeouts",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lpCommTimeouts",
                    "type": "LPCOMMTIMEOUTS",
                    "description": "A pointer to a\nCOMMTIMEOUTS structure that contains the new time-out values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetCurrentDirectory",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCTSTR",
                    "description": "The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory. For more info, see Naming files, paths, and namespaces. By default, the name is limited to MAX_PATH characters. The final character before the null character must be a backslash ('\\'). If you don't specify the backslash, then it will be added for you. Therefore, specify >MAX_PATH-2 characters for the path unless you include the trailing backslash; in which case, specify MAX_PATH-1 characters for the path.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetDefaultCommConfigA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setdefaultcommconfiga",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCSTR",
                    "description": "The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "A pointer to a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "dwSize",
                    "type": "DWORD",
                    "description": "The size of the structure pointed to by lpCC, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetDefaultCommConfigW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setdefaultcommconfigw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszName",
                    "type": "LPCWSTR",
                    "description": "The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.",
                    "possible_constants": []
                },
                {
                    "name": "lpCC",
                    "type": "LPCOMMCONFIG",
                    "description": "A pointer to a\nCOMMCONFIG structure.",
                    "possible_constants": []
                },
                {
                    "name": "dwSize",
                    "type": "DWORD",
                    "description": "The size of the structure pointed to by lpCC, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetDllDirectoryA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setdlldirectorya",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCSTR",
                    "description": "The directory to be added to the search path. If this parameter is an empty string (\"\"), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetDllDirectoryW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setdlldirectoryw",
            "description": "",
            "parameters": [
                {
                    "name": "lpPathName",
                    "type": "LPCWSTR",
                    "description": "The directory to be added to the search path. If this parameter is an empty string (\"\"), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetEnvironmentVariable",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCTSTR",
                    "description": "The name of the environment variable. The operating system creates the environment variable if it does not exist and lpValue is not NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpValue",
                    "type": "LPCTSTR",
                    "description": "The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see\nEnvironment Variables. Windows Server\u00a02003 and Windows\u00a0XP:\u00a0\u00a0The total size of the environment block for a process may not exceed 32,767 characters. If this parameter is NULL, the variable is deleted from the current process's environment.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileAttributesTransactedA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfileattributestransacteda",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the file whose attributes are to be set. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE.",
                    "possible_constants": []
                },
                {
                    "name": "dwFileAttributes",
                    "type": "DWORD",
                    "description": "The file attributes to set for the file. For a list of file attribute value and their descriptions, see\nFile Attribute Constants. This parameter can be\none or more values, combined using the bitwise-OR operator. However, all other values override\nFILE_ATTRIBUTE_NORMAL. Not all attributes are supported by this function. For more information, see the Remarks section. The following is a list of supported attribute values.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileAttributesTransactedW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfileattributestransactedw",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the file whose attributes are to be set. The file must reside on the local computer; otherwise, the function fails and the last error code is set to\nERROR_TRANSACTIONS_UNSUPPORTED_REMOTE. By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.",
                    "possible_constants": []
                },
                {
                    "name": "dwFileAttributes",
                    "type": "DWORD",
                    "description": "The file attributes to set for the file. For a list of file attribute value and their descriptions, see\nFile Attribute Constants. This parameter can be\none or more values, combined using the bitwise-OR operator. However, all other values override\nFILE_ATTRIBUTE_NORMAL. Not all attributes are supported by this function. For more information, see the Remarks section. The following is a list of supported attribute values.",
                    "possible_constants": []
                },
                {
                    "name": "hTransaction",
                    "type": "HANDLE",
                    "description": "A handle to the transaction. This handle is returned by the\nCreateTransaction function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileBandwidthReservation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfilebandwidthreservation",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file.",
                    "possible_constants": []
                },
                {
                    "name": "nPeriodMilliseconds",
                    "type": "DWORD",
                    "description": "The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the\nkernel until the time the I/O should be completed. The minimum supported value for the file\nstream can be determined by looking at the value returned through the\nlpPeriodMilliseconds parameter to the\nGetFileBandwidthReservation function,\non a handle that has not had a bandwidth reservation set.",
                    "possible_constants": []
                },
                {
                    "name": "nBytesPerPeriod",
                    "type": "DWORD",
                    "description": "The bandwidth to reserve, in bytes per period. The maximum supported value for the file\nstream can be determined by looking at the value returned through the\nlpBytesPerPeriod parameter to the\nGetFileBandwidthReservation function,\non a handle that has not had a bandwidth reservation set.",
                    "possible_constants": []
                },
                {
                    "name": "bDiscardable",
                    "type": "BOOL",
                    "description": "Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation\nbefore the period expires. If one of the drivers for the specified file stream does not support this\nfunctionality, this function may return success and ignore the flag. To verify whether the setting will be\nhonored, call the\nGetFileBandwidthReservation function\nusing the same hFile handle and examine the *pDiscardable\nreturn value. [out] lpTransferSize A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by\nthe application. All I/O requests should be multiples of TransferSize. [out] lpNumOutstandingRequests A pointer to a variable that receives the number of TransferSize chunks the\napplication should allow to be outstanding with the operating system. This allows the storage stack to keep the\ndevice busy and allows maximum throughput.",
                    "possible_constants": []
                },
                {
                    "name": "lpTransferSize",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpNumOutstandingRequests",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileCompletionNotificationModes",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfilecompletionnotificationmodes",
            "description": "",
            "parameters": [
                {
                    "name": "FileHandle",
                    "type": "HANDLE",
                    "description": "A handle to the file.",
                    "possible_constants": []
                },
                {
                    "name": "Flags",
                    "type": "UCHAR",
                    "description": "The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for\na file handle, it cannot be removed.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileSecurityA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfilesecuritya",
            "description": "",
            "parameters": [
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.",
                    "possible_constants": []
                },
                {
                    "name": "SecurityInformation",
                    "type": "SECURITY_INFORMATION",
                    "description": "Specifies a\nSECURITY_INFORMATION structure that identifies the contents of the security descriptor pointed to by the pSecurityDescriptor parameter.",
                    "possible_constants": []
                },
                {
                    "name": "pSecurityDescriptor",
                    "type": "PSECURITY_DESCRIPTOR",
                    "description": "A pointer to a\nSECURITY_DESCRIPTOR structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileShortNameA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfileshortnamea",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file. The file must be opened with DELETE, and with the FILE_FLAG_BACKUP_SEMANTICS file attribute.",
                    "possible_constants": []
                },
                {
                    "name": "lpShortName",
                    "type": "LPCSTR",
                    "description": "A pointer to a string that specifies the short name for the file. Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the hFile parameter. If  a short file name does not exist, the function will do nothing and return success. Windows Server\u00a02008, Windows\u00a0Vista, Windows Server\u00a02003 and Windows\u00a0XP:\u00a0This behavior is not supported. The parameter must contain a valid string of one or more characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFileShortNameW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfileshortnamew",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the file. The file must be opened with DELETE, and with the FILE_FLAG_BACKUP_SEMANTICS file attribute.",
                    "possible_constants": []
                },
                {
                    "name": "lpShortName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a string that specifies the short name for the file. Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the hFile parameter. If  a short file name does not exist, the function will do nothing and return success. Windows Server\u00a02008, Windows\u00a0Vista, Windows Server\u00a02003 and Windows\u00a0XP:\u00a0This behavior is not supported. The parameter must contain a valid string of one or more characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFirmwareEnvironmentVariableA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariablea",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\". If the system does not support GUID-based namespaces, this parameter is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "pValue",
                    "type": "PVOID",
                    "description": "A pointer to the new value for the  firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pBuffer buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFirmwareEnvironmentVariableExA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariableexa",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "pValue",
                    "type": "PVOID",
                    "description": "A pointer to the new value for the  firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pValue buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,\nVARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or\nVARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via dwAttributes,\nsetting this value to zero will result in the deletion of this variable.",
                    "possible_constants": []
                },
                {
                    "name": "dwAttributes",
                    "type": "DWORD",
                    "description": "Bitmask to set UEFI variable attributes associated with the variable. See also UEFI Spec 2.3.1, Section 7.2.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFirmwareEnvironmentVariableExW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariableexw",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCWSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "pValue",
                    "type": "PVOID",
                    "description": "A pointer to the new value for the  firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pValue buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,\nVARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or\nVARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via dwAttributes,\nsetting this value to zero will result in the deletion of this variable.",
                    "possible_constants": []
                },
                {
                    "name": "dwAttributes",
                    "type": "DWORD",
                    "description": "Bitmask to set UEFI variable attributes associated with the variable. See also UEFI Spec 2.3.1, Section 7.2.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetFirmwareEnvironmentVariableW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfirmwareenvironmentvariablew",
            "description": "",
            "parameters": [
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "The name of the firmware environment variable. The pointer must not be NULL.",
                    "possible_constants": []
                },
                {
                    "name": "lpGuid",
                    "type": "LPCWSTR",
                    "description": "The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\". If the system does not support GUID-based namespaces, this parameter is ignored.",
                    "possible_constants": []
                },
                {
                    "name": "pValue",
                    "type": "PVOID",
                    "description": "A pointer to the new value for the  firmware environment variable.",
                    "possible_constants": []
                },
                {
                    "name": "nSize",
                    "type": "DWORD",
                    "description": "The size of the pBuffer buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetHandleCount",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-sethandlecount",
            "description": "",
            "parameters": [
                {
                    "name": "uNumber",
                    "type": "UINT",
                    "description": " The requested number of available file handles.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetMailslotInfo",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setmailslotinfo",
            "description": "",
            "parameters": [
                {
                    "name": "hMailslot",
                    "type": "HANDLE",
                    "description": "A handle to a mailslot. The\nCreateMailslot function must create this handle.",
                    "possible_constants": []
                },
                {
                    "name": "lReadTimeout",
                    "type": "DWORD",
                    "description": "The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings. This time-out value applies to all subsequent read operations and to all inherited mailslot handles.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetProcessAffinityMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessaffinitymask",
            "description": "",
            "parameters": [
                {
                    "name": "hProcess",
                    "type": "HANDLE",
                    "description": "A handle to the process whose affinity mask is to be set. This handle must have the PROCESS_SET_INFORMATION access right. For more information, see\nProcess Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwProcessAffinityMask",
                    "type": "DWORD_PTR",
                    "description": "The affinity mask for the threads of the process. On a system with more than 64 processors, the affinity mask must specify processors in a single processor group.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetProcessDEPPolicy",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy",
            "description": "",
            "parameters": [
                {
                    "name": "dwFlags",
                    "type": "DWORD",
                    "description": "A DWORD that can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetSearchPathMode",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setsearchpathmode",
            "description": "",
            "parameters": [
                {
                    "name": "Flags",
                    "type": "DWORD",
                    "description": "The search mode to use.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetSystemPowerState",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setsystempowerstate",
            "description": "",
            "parameters": [
                {
                    "name": "fSuspend",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the system is suspended. If the parameter is\nFALSE, the system hibernates.",
                    "possible_constants": []
                },
                {
                    "name": "fForce",
                    "type": "BOOL",
                    "description": "This parameter has no effect.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetTapeParameters",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-settapeparameters",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device for which to set configuration information. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwOperation",
                    "type": "DWORD",
                    "description": "Type of information to set. This parameter must be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpTapeInformation",
                    "type": "LPVOID",
                    "description": "Pointer to a structure that contains the information to set. If the dwOperation parameter is SET_TAPE_MEDIA_INFORMATION, lpTapeInformation points to a\nTAPE_SET_MEDIA_PARAMETERS structure. If dwOperation is SET_TAPE_DRIVE_INFORMATION, lpTapeInformation points to a\nTAPE_SET_DRIVE_PARAMETERS structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetTapePosition",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-settapeposition",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device on which to set the tape position. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwPositionMethod",
                    "type": "DWORD",
                    "description": "Type of positioning to perform. This parameter must be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwPartition",
                    "type": "DWORD",
                    "description": "Partition to position within. If dwPartition is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.",
                    "possible_constants": []
                },
                {
                    "name": "dwOffsetLow",
                    "type": "DWORD",
                    "description": "Low-order bits of the block address or count for the position operation specified by the dwPositionMethod parameter.",
                    "possible_constants": []
                },
                {
                    "name": "dwOffsetHigh",
                    "type": "DWORD",
                    "description": "High-order bits of the block address or count for the position operation specified by the dwPositionMethod parameter. If the high-order bits are not required, this parameter should be zero.",
                    "possible_constants": []
                },
                {
                    "name": "bImmediate",
                    "type": "BOOL",
                    "description": "Indicates whether to return as soon as the move operation begins. If this parameter is TRUE, the function returns immediately; if FALSE, the function does not return until the move operation has been completed.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadAffinityMask",
            "return_type": "DWORD_PTR",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask",
            "description": "",
            "parameters": [
                {
                    "name": "hThread",
                    "type": "HANDLE",
                    "description": "A handle to the thread whose affinity mask is to be set. This handle must have the THREAD_SET_INFORMATION or THREAD_SET_LIMITED_INFORMATION access right and the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see\nThread Security and Access Rights. Windows Server\u00a02003 and Windows\u00a0XP:\u00a0\u00a0The handle must have the THREAD_SET_INFORMATION and THREAD_QUERY_INFORMATION access rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwThreadAffinityMask",
                    "type": "DWORD_PTR",
                    "description": "The affinity mask for the thread. On a system with more than 64 processors, the affinity mask must specify processors in the thread's current processor group.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadExecutionState",
            "return_type": "EXECUTION_STATE",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadexecutionstate",
            "description": "",
            "parameters": [
                {
                    "name": "esFlags",
                    "type": "EXECUTION_STATE",
                    "description": "The thread's execution requirements. This parameter can be one or more of the following values.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackCleanupGroup",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbackcleanupgroup",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                },
                {
                    "name": "ptpcg",
                    "type": "PTP_CLEANUP_GROUP",
                    "description": "A TP_CLEANUP_GROUP structure that defines the cleanup group. The CreateThreadpoolCleanupGroup function returns this structure.",
                    "possible_constants": []
                },
                {
                    "name": "pfng",
                    "type": "PTP_CLEANUP_GROUP_CANCEL_CALLBACK",
                    "description": "The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call CloseThreadpoolCleanupGroupMembers.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackLibrary",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbacklibrary",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                },
                {
                    "name": "mod",
                    "type": "PVOID",
                    "description": "A handle to the DLL.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackPersistent",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbackpersistent",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackPool",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbackpool",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                },
                {
                    "name": "ptpp",
                    "type": "PTP_POOL",
                    "description": "A TP_POOL structure that defines the thread pool. The CreateThreadpool function returns this structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackPriority",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbackpriority",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                },
                {
                    "name": "Priority",
                    "type": "TP_CALLBACK_PRIORITY",
                    "description": "The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following TP_CALLBACK_PRIORITY enumeration values:",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetThreadpoolCallbackRunsLong",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadpoolcallbackrunslong",
            "description": "",
            "parameters": [
                {
                    "name": "pcbe",
                    "type": "PTP_CALLBACK_ENVIRON",
                    "description": "A TP_CALLBACK_ENVIRON structure that defines the callback environment. The InitializeThreadpoolEnvironment function returns this structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetUmsThreadInformation",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setumsthreadinformation",
            "description": "",
            "parameters": [
                {
                    "name": "UmsThread",
                    "type": "PUMS_CONTEXT",
                    "description": "The size of the UmsThreadInformation buffer, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInfoClass",
                    "type": "UMS_THREAD_INFO_CLASS",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInformation",
                    "type": "PVOID",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "UmsThreadInformationLength",
                    "type": "ULONG",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetupComm",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setupcomm",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "dwInQueue",
                    "type": "DWORD",
                    "description": "The recommended size of the device's internal input buffer, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "dwOutQueue",
                    "type": "DWORD",
                    "description": "The recommended size of the device's internal output buffer, in bytes.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetVolumeLabelA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumelabela",
            "description": "",
            "parameters": [
                {
                    "name": "lpRootPathName",
                    "type": "LPCSTR",
                    "description": "A pointer to a string that contains the volume's drive letter (for example, X:) or the path\nof a mounted folder that is associated with the volume (for example, Y:\\MountX). The string must\nend with a trailing backslash (''). If this parameter is NULL, the root of the\ncurrent directory is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpVolumeName",
                    "type": "LPCSTR",
                    "description": "A pointer to a string that contains the new label for the volume. If this parameter is\nNULL, the function deletes any existing label from the specified volume and does not\nassign a new label.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetVolumeLabelW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumelabelw",
            "description": "",
            "parameters": [
                {
                    "name": "lpRootPathName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a string that contains the volume's drive letter (for example, X:) or the path\nof a mounted folder that is associated with the volume (for example, Y:\\MountX). The string must\nend with a trailing backslash (''). If this parameter is NULL, the root of the\ncurrent directory is used.",
                    "possible_constants": []
                },
                {
                    "name": "lpVolumeName",
                    "type": "LPCWSTR",
                    "description": "A pointer to a string that contains the new label for the volume. If this parameter is\nNULL, the function deletes any existing label from the specified volume and does not\nassign a new label.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetVolumeMountPointA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumemountpointa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPCSTR",
                    "description": "The user-mode path to be associated with the volume. This may be a drive letter (for example, \"X:\\\") or a directory\non another volume (for example, \"Y:\\MountX\\\"). The string must end with a trailing backslash ('\\').",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeName",
                    "type": "LPCSTR",
                    "description": "A volume GUID path for the volume. This string must be of the form\n\"\\\\?\\Volume{GUID}\\\" where GUID is a GUID that identifies\nthe volume. The \"\\\\?\\\" turns off path parsing and is ignored as part of the path, as discussed in\nNaming a Volume.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetVolumeMountPointW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumemountpointw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszVolumeMountPoint",
                    "type": "LPCWSTR",
                    "description": "The user-mode path to be associated with the volume. This may be a drive letter (for example, \"X:\\\") or a directory\non another volume (for example, \"Y:\\MountX\\\"). The string must end with a trailing backslash ('\\').",
                    "possible_constants": []
                },
                {
                    "name": "lpszVolumeName",
                    "type": "LPCWSTR",
                    "description": "A volume GUID path for the volume. This string must be of the form\n\"\\\\?\\Volume{GUID}\\\" where GUID is a GUID that identifies\nthe volume. The \"\\\\?\\\" turns off path parsing and is ignored as part of the path, as discussed in\nNaming a Volume.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SetXStateFeaturesMask",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setxstatefeaturesmask",
            "description": "",
            "parameters": [
                {
                    "name": "Context",
                    "type": "PCONTEXT",
                    "description": "A pointer to a CONTEXT structure that has been\ninitialized with InitializeContext.",
                    "possible_constants": []
                },
                {
                    "name": "FeatureMask",
                    "type": "DWORD64",
                    "description": "A mask of XState features to set in the specified\nCONTEXT structure.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "SwitchToFiber",
            "return_type": "void",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-switchtofiber",
            "description": "",
            "parameters": [
                {
                    "name": "lpFiber",
                    "type": "LPVOID",
                    "description": "The address of the fiber to be scheduled.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "TransmitCommChar",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-transmitcommchar",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle.",
                    "possible_constants": []
                },
                {
                    "name": "cChar",
                    "type": "char",
                    "description": "The character to be transmitted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "UmsThreadYield",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-umsthreadyield",
            "description": "",
            "parameters": [
                {
                    "name": "SchedulerParam",
                    "type": "PVOID",
                    "description": "A parameter to pass to the scheduler thread's UmsSchedulerProc function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "UnregisterApplicationRecoveryCallback",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-unregisterapplicationrecoverycallback",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "UnregisterApplicationRestart",
            "return_type": "HRESULT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-unregisterapplicationrestart",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "UnregisterWait",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-unregisterwait",
            "description": "",
            "parameters": [
                {
                    "name": "WaitHandle",
                    "type": "HANDLE",
                    "description": "The wait handle. This handle is returned by the\nRegisterWaitForSingleObject function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "UpdateResourceA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-updateresourcea",
            "description": "",
            "parameters": [
                {
                    "name": "hUpdate",
                    "type": "HANDLE",
                    "description": "Type: HANDLE A module handle returned by the BeginUpdateResource function, referencing the file to be updated.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The resource type to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string \"#258\" represents the identifier 258. For a list of predefined resource types, see Resource Types.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCSTR",
                    "description": "Type: LPCTSTR The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.",
                    "possible_constants": []
                },
                {
                    "name": "wLanguage",
                    "type": "WORD",
                    "description": "Type: WORD The language identifier of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the MAKELANGID  macro.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "Type: LPVOID The resource data to be inserted into the file indicated by hUpdate. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by hUpdate, not the data provided by LoadIcon, LoadString, or other resource-specific load functions. All data containing strings or text must be in Unicode format. lpData must not point to ANSI data. If lpData is NULL and cbData is 0, the specified resource is deleted from the file indicated by hUpdate.",
                    "possible_constants": []
                },
                {
                    "name": "cb",
                    "type": "DWORD",
                    "description": "Type: DWORD The size, in bytes, of the resource data at lpData.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "UpdateResourceW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-updateresourcew",
            "description": "",
            "parameters": [
                {
                    "name": "hUpdate",
                    "type": "HANDLE",
                    "description": "Type: HANDLE A module handle returned by the BeginUpdateResource function, referencing the file to be updated.",
                    "possible_constants": []
                },
                {
                    "name": "lpType",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The resource type to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string \"#258\" represents the identifier 258. For a list of predefined resource types, see Resource Types.",
                    "possible_constants": []
                },
                {
                    "name": "lpName",
                    "type": "LPCWSTR",
                    "description": "Type: LPCTSTR The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.",
                    "possible_constants": []
                },
                {
                    "name": "wLanguage",
                    "type": "WORD",
                    "description": "Type: WORD The language identifier of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the MAKELANGID  macro.",
                    "possible_constants": []
                },
                {
                    "name": "lpData",
                    "type": "LPVOID",
                    "description": "Type: LPVOID The resource data to be inserted into the file indicated by hUpdate. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by hUpdate, not the data provided by LoadIcon, LoadString, or other resource-specific load functions. All data containing strings or text must be in Unicode format. lpData must not point to ANSI data. If lpData is NULL and cbData is 0, the specified resource is deleted from the file indicated by hUpdate.",
                    "possible_constants": []
                },
                {
                    "name": "cb",
                    "type": "DWORD",
                    "description": "Type: DWORD The size, in bytes, of the resource data at lpData.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "VerifyVersionInfoA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-verifyversioninfoa",
            "description": "",
            "parameters": [
                {
                    "name": "lpVersionInformation",
                    "type": "LPOSVERSIONINFOEXA",
                    "description": "A pointer to an\nOSVERSIONINFOEX structure containing the operating system version requirements to compare. The dwTypeMask parameter indicates the members of this structure that contain information to compare. You must set the dwOSVersionInfoSize member of this structure to sizeof(OSVERSIONINFOEX). You must also specify valid data for the members indicated by dwTypeMask. The function ignores structure members for which the corresponding dwTypeMask bit is not set.",
                    "possible_constants": []
                },
                {
                    "name": "dwTypeMask",
                    "type": "DWORD",
                    "description": "A mask that indicates the members of the\nOSVERSIONINFOEX structure to be tested. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwlConditionMask",
                    "type": "DWORDLONG",
                    "description": "The type of comparison to be used for each lpVersionInfo member being compared. To build this value, call the\nVerSetConditionMask function or the\nVER_SET_CONDITION macro once for each\nOSVERSIONINFOEX member being compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "VerifyVersionInfoW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-verifyversioninfow",
            "description": "",
            "parameters": [
                {
                    "name": "lpVersionInformation",
                    "type": "LPOSVERSIONINFOEXW",
                    "description": "A pointer to an\nOSVERSIONINFOEX structure containing the operating system version requirements to compare. The dwTypeMask parameter indicates the members of this structure that contain information to compare. You must set the dwOSVersionInfoSize member of this structure to sizeof(OSVERSIONINFOEX). You must also specify valid data for the members indicated by dwTypeMask. The function ignores structure members for which the corresponding dwTypeMask bit is not set.",
                    "possible_constants": []
                },
                {
                    "name": "dwTypeMask",
                    "type": "DWORD",
                    "description": "A mask that indicates the members of the\nOSVERSIONINFOEX structure to be tested. This parameter can be one or more of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwlConditionMask",
                    "type": "DWORDLONG",
                    "description": "The type of comparison to be used for each lpVersionInfo member being compared. To build this value, call the\nVerSetConditionMask function or the\nVER_SET_CONDITION macro once for each\nOSVERSIONINFOEX member being compared.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WaitCommEvent",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-waitcommevent",
            "description": "",
            "parameters": [
                {
                    "name": "hFile",
                    "type": "HANDLE",
                    "description": "A handle to the communications device. The\nCreateFile function returns this handle. [out] lpEvtMask A pointer to a variable that receives a mask indicating the type of event that occurred. If an error occurs, the value is zero; otherwise, it is one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "lpEvtMask",
                    "type": "LPDWORD",
                    "description": "",
                    "possible_constants": []
                },
                {
                    "name": "lpOverlapped",
                    "type": "LPOVERLAPPED",
                    "description": "A pointer to an\nOVERLAPPED structure. This structure is required if hFile was opened with FILE_FLAG_OVERLAPPED. If hFile was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must point to a valid OVERLAPPED structure. If hFile was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is NULL, the function can incorrectly report that the operation is complete. If hFile was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL,\nWaitCommEvent is performed as an overlapped operation. In this case, the OVERLAPPED structure must contain a handle to a manual-reset event object (created by using the\nCreateEvent function). If hFile was not opened with FILE_FLAG_OVERLAPPED,\nWaitCommEvent does not return until one of the specified events or an error occurs.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WaitNamedPipeA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-waitnamedpipea",
            "description": "",
            "parameters": [
                {
                    "name": "lpNamedPipeName",
                    "type": "LPCSTR",
                    "description": "The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the servername if the pipe is local. The following pipe name format is used: \\\\servername\\pipe\\pipename",
                    "possible_constants": []
                },
                {
                    "name": "nTimeOut",
                    "type": "DWORD",
                    "description": "The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WinExec",
            "return_type": "UINT",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec",
            "description": "",
            "parameters": [
                {
                    "name": "lpCmdLine",
                    "type": "LPCSTR",
                    "description": "The command line (file name plus optional parameters) for the application to be executed. If the name of the executable file in the lpCmdLine parameter does not contain a directory path, the system searches for the executable file in this sequence:",
                    "possible_constants": []
                },
                {
                    "name": "uCmdShow",
                    "type": "UINT",
                    "description": "The display options. For a list of the acceptable values, see the description of the nCmdShow parameter of the\nShowWindow function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WinMain",
            "return_type": "int __clrcall",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winmain",
            "description": "",
            "parameters": [
                {
                    "name": "hInstance",
                    "type": "HINSTANCE",
                    "description": "Type: HINSTANCE A handle to the current instance of the application.",
                    "possible_constants": []
                },
                {
                    "name": "hPrevInstance",
                    "type": "HINSTANCE",
                    "description": "Type: HINSTANCE A handle to the previous instance of the application. This parameter is always NULL. If you need to detect whether another instance already exists, create a uniquely named mutex using the CreateMutex function. CreateMutex will succeed even if the mutex already exists, but the  function will return ERROR_ALREADY_EXISTS. This indicates that another instance of your application exists, because it created the mutex first. However, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.",
                    "possible_constants": []
                },
                {
                    "name": "lpCmdLine",
                    "type": "LPSTR",
                    "description": "Type: LPSTR The command line for the application, excluding the program name. To retrieve the entire command line, use the GetCommandLine function.",
                    "possible_constants": []
                },
                {
                    "name": "nShowCmd",
                    "type": "int",
                    "description": "Type: int Controls how the window is to be shown. This parameter can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "Wow64GetThreadSelectorEntry",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-wow64getthreadselectorentry",
            "description": "",
            "parameters": [
                {
                    "name": "hThread",
                    "type": "HANDLE",
                    "description": "A handle to the thread containing the\nspecified selector.  The handle must have been created with\nTHREAD_QUERY_INFORMATION access to the thread. For more information, see\nThread Security and Access Rights.",
                    "possible_constants": []
                },
                {
                    "name": "dwSelector",
                    "type": "DWORD",
                    "description": "The global or local selector value to look up in the thread's descriptor tables. [out] lpSelectorEntry A pointer to a\nWOW64_LDT_ENTRY structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.",
                    "possible_constants": []
                },
                {
                    "name": "lpSelectorEntry",
                    "type": "PWOW64_LDT_ENTRY",
                    "description": "",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteEncryptedFileRaw",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeencryptedfileraw",
            "description": "",
            "parameters": [
                {
                    "name": "pfImportCallback",
                    "type": "PFE_IMPORT_FUNC",
                    "description": "A pointer to the import callback function. The system calls the callback function multiple times, each time\npassing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the\ncallback function signals that the entire file has been processed, it tells the system that the restore\noperation is finished. For more information, see\nImportCallback.",
                    "possible_constants": []
                },
                {
                    "name": "pvCallbackContext",
                    "type": "PVOID",
                    "description": "A pointer to an application-defined and allocated context block. The system passes this pointer to the\ncallback function as a parameter so that the callback function can have access to application-specific data.\nThis can be a structure and can contain any data the application needs, such as the handle to the file that will\ncontain the backup copy of the encrypted file.",
                    "possible_constants": []
                },
                {
                    "name": "pvContext",
                    "type": "PVOID",
                    "description": "A pointer to a system-defined context block. The context block is returned by the\nOpenEncryptedFileRaw function. Do not modify\nit.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileSectionA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilesectiona",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section in which data is written. This section name is typically the name of the calling application.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and lpFileName does not contain a full path, the function creates the file in the Windows directory. If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileSectionW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilesectionw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section in which data is written. This section name is typically the name of the calling application.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and lpFileName does not contain a full path, the function creates the file in the Windows directory. If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileStringA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilestringa",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries within the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCSTR",
                    "description": "The name of the initialization file. If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileStringW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilestringw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries within the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpFileName",
                    "type": "LPCWSTR",
                    "description": "The name of the initialization file. If the file already exists and consists of Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileStructA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilestructa",
            "description": "",
            "parameters": [
                {
                    "name": "lpszSection",
                    "type": "LPCSTR",
                    "description": "The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters.",
                    "possible_constants": []
                },
                {
                    "name": "lpszKey",
                    "type": "LPCSTR",
                    "description": "The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all keys and entries within the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpStruct",
                    "type": "LPVOID",
                    "description": "The data to be copied. If this parameter is NULL, the key is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "uSizeStruct",
                    "type": "UINT",
                    "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "szFile",
                    "type": "LPCSTR",
                    "description": "The  name of the initialization file. If this parameter is NULL, the information is copied into the Win.ini file. If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WritePrivateProfileStructW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprivateprofilestructw",
            "description": "",
            "parameters": [
                {
                    "name": "lpszSection",
                    "type": "LPCWSTR",
                    "description": "The name of the section to which the struct data will be copied. If the section does not exist, it is created. The name of the section is case independent.",
                    "possible_constants": []
                },
                {
                    "name": "lpszKey",
                    "type": "LPCWSTR",
                    "description": "The name of the key to be associated with a struct. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all keys and entries within the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpStruct",
                    "type": "LPVOID",
                    "description": "The data to be copied. If this parameter is NULL, the key is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "uSizeStruct",
                    "type": "UINT",
                    "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes.",
                    "possible_constants": []
                },
                {
                    "name": "szFile",
                    "type": "LPCWSTR",
                    "description": "The  name of the initialization file. If this parameter is NULL, the information is copied into the Win.ini file. If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteProfileSectionA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprofilesectiona",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The name of the section. This section name is typically the name of the calling application.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes. If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteProfileSectionW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprofilesectionw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The name of the section. This section name is typically the name of the calling application.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes. If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteProfileStringA",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprofilestringa",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCSTR",
                    "description": "The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCSTR",
                    "description": "The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries in the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCSTR",
                    "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteProfileStringW",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writeprofilestringw",
            "description": "",
            "parameters": [
                {
                    "name": "lpAppName",
                    "type": "LPCWSTR",
                    "description": "The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.",
                    "possible_constants": []
                },
                {
                    "name": "lpKeyName",
                    "type": "LPCWSTR",
                    "description": "The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries in the section, is deleted.",
                    "possible_constants": []
                },
                {
                    "name": "lpString",
                    "type": "LPCWSTR",
                    "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WriteTapemark",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-writetapemark",
            "description": "",
            "parameters": [
                {
                    "name": "hDevice",
                    "type": "HANDLE",
                    "description": "Handle to the device on which to write tapemarks. This handle is created by using the\nCreateFile function.",
                    "possible_constants": []
                },
                {
                    "name": "dwTapemarkType",
                    "type": "DWORD",
                    "description": "Type of tapemarks to write. This parameter can be one of the following values.",
                    "possible_constants": []
                },
                {
                    "name": "dwTapemarkCount",
                    "type": "DWORD",
                    "description": "Number of tapemarks to write.",
                    "possible_constants": []
                },
                {
                    "name": "bImmediate",
                    "type": "BOOL",
                    "description": "If this parameter is TRUE, the function returns immediately; if it is FALSE, the function does not return until the operation has been completed.",
                    "possible_constants": []
                }
            ],
            "flags": []
        },
        {
            "name": "WTSGetActiveConsoleSessionId",
            "return_type": "DWORD",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-wtsgetactiveconsolesessionid",
            "description": "",
            "parameters": [],
            "flags": []
        },
        {
            "name": "ZombifyActCtx",
            "return_type": "BOOL",
            "msdn": "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-zombifyactctx",
            "description": "",
            "parameters": [
                {
                    "name": "hActCtx",
                    "type": "HANDLE",
                    "description": "Handle to the activation context that is to be deactivated.",
                    "possible_constants": []
                }
            ],
            "flags": []
        }
    ]
}